/* 
 * Copyright (c) 2008-2012, Andy Bierman, All Rights Reserved.
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *

*** Generated by yangdump 2.12-0

  Combined SIL module
  module ietf-i2rs-rib
  revision 2017-12-05
  namespace urn:ietf:params:xml:ns:yang:ietf-i2rs-rib
  organization IETF I2RS (Interface to Routing System) Working Group

 */

#include <libxml/xmlstring.h>

#include "procdefs.h"
#include "agt.h"
#include "agt_cb.h"
#include "agt_not.h"
#include "agt_rpc.h"
#include "agt_timer.h"
#include "agt_util.h"
#include "dlq.h"
#include "ncx.h"
#include "ncx_feature.h"
#include "ncxmod.h"
#include "ncxtypes.h"
#include "rpc.h"
#include "ses.h"
#include "status.h"
#include "val.h"
#include "val_util.h"
#include "xml_util.h"
#include "ietf-i2rs-rib.h"

#include "com.h"

/* module static variables */
static ncx_module_t *ietf_i2rs_rib_mod;
static obj_template_t *routing_instance_obj;
static obj_template_t *rib_add_obj;
static obj_template_t *rib_delete_obj;
static obj_template_t *route_add_obj;
static obj_template_t *route_delete_obj;
static obj_template_t *route_update_obj;
static obj_template_t *nh_add_obj;
static obj_template_t *nh_delete_obj;
static obj_template_t *nexthop_resolution_status_change_obj;
static obj_template_t *route_change_obj;
static val_value_t *routing_instance_val;

/* put your static variables here */

/********************************************************************
* FUNCTION y_ietf_i2rs_rib_init_static_vars
* 
* initialize module static variables
* 
********************************************************************/
static void y_ietf_i2rs_rib_init_static_vars (void)
{
  ietf_i2rs_rib_mod = NULL;
  routing_instance_obj = NULL;
  rib_add_obj = NULL;
  rib_delete_obj = NULL;
  route_add_obj = NULL;
  route_delete_obj = NULL;
  route_update_obj = NULL;
  nh_add_obj = NULL;
  nh_delete_obj = NULL;
  nexthop_resolution_status_change_obj = NULL;
  route_change_obj = NULL;
  routing_instance_val = NULL;

  /* init your static variables here */

} /* y_ietf_i2rs_rib_init_static_vars */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_name_edit
* 
* Edit database object callback
* Path: /routing-instance/name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_name_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_name_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_name_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_interface_list_name_edit
* 
* Edit database object callback
* Path: /routing-instance/interface-list/name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_interface_list_name_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_interface_list_name_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_interface_list_name_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_interface_list_edit
* 
* Edit database object callback
* Path: /routing-instance/interface-list
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_interface_list_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_interface_list_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_interface_list_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_router_id_edit
* 
* Edit database object callback
* Path: /routing-instance/router-id
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_router_id_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_router_id_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_router_id_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_lookup_limit_edit
* 
* Edit database object callback
* Path: /routing-instance/lookup-limit
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_lookup_limit_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_lookup_limit_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_lookup_limit_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_name_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_name_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_name_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_name_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_address_family_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/address-family
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_address_family_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_address_family_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_address_family_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_ip_rpf_check_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/ip-rpf-check
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_ip_rpf_check_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_ip_rpf_check_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_ip_rpf_check_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_route_index_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/route-index
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_route_index_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_route_index_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_route_index_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_match_route_type_ipv4_ipv4_ip_route_match_type_dest_ipv4_address_dest_ipv4_prefix_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/match/route-type/ipv4/ipv4/ip-route-match-type/dest-ipv4-address/dest-ipv4-prefix
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_match_route_type_ipv4_ipv4_ip_route_match_type_dest_ipv4_address_dest_ipv4_prefix_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_match_route_type_ipv4_ipv4_ip_route_match_type_dest_ipv4_address_dest_ipv4_prefix_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_match_route_type_ipv4_ipv4_ip_route_match_type_dest_ipv4_address_dest_ipv4_prefix_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_match_route_type_ipv4_ipv4_ip_route_match_type_src_ipv4_address_src_ipv4_prefix_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/match/route-type/ipv4/ipv4/ip-route-match-type/src-ipv4-address/src-ipv4-prefix
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_match_route_type_ipv4_ipv4_ip_route_match_type_src_ipv4_address_src_ipv4_prefix_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_match_route_type_ipv4_ipv4_ip_route_match_type_src_ipv4_address_src_ipv4_prefix_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_match_route_type_ipv4_ipv4_ip_route_match_type_src_ipv4_address_src_ipv4_prefix_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_match_route_type_ipv4_ipv4_ip_route_match_type_dest_src_ipv4_address_dest_src_ipv4_address_dest_ipv4_prefix_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/match/route-type/ipv4/ipv4/ip-route-match-type/dest-src-ipv4-address/dest-src-ipv4-address/dest-ipv4-prefix
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_match_route_type_ipv4_ipv4_ip_route_match_type_dest_src_ipv4_address_dest_src_ipv4_address_dest_ipv4_prefix_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_match_route_type_ipv4_ipv4_ip_route_match_type_dest_src_ipv4_address_dest_src_ipv4_address_dest_ipv4_prefix_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_match_route_type_ipv4_ipv4_ip_route_match_type_dest_src_ipv4_address_dest_src_ipv4_address_dest_ipv4_prefix_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_match_route_type_ipv4_ipv4_ip_route_match_type_dest_src_ipv4_address_dest_src_ipv4_address_src_ipv4_prefix_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/match/route-type/ipv4/ipv4/ip-route-match-type/dest-src-ipv4-address/dest-src-ipv4-address/src-ipv4-prefix
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_match_route_type_ipv4_ipv4_ip_route_match_type_dest_src_ipv4_address_dest_src_ipv4_address_src_ipv4_prefix_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_match_route_type_ipv4_ipv4_ip_route_match_type_dest_src_ipv4_address_dest_src_ipv4_address_src_ipv4_prefix_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_match_route_type_ipv4_ipv4_ip_route_match_type_dest_src_ipv4_address_dest_src_ipv4_address_src_ipv4_prefix_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_match_route_type_ipv4_ipv4_ip_route_match_type_dest_src_ipv4_address_dest_src_ipv4_address_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/match/route-type/ipv4/ipv4/ip-route-match-type/dest-src-ipv4-address/dest-src-ipv4-address
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_match_route_type_ipv4_ipv4_ip_route_match_type_dest_src_ipv4_address_dest_src_ipv4_address_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_match_route_type_ipv4_ipv4_ip_route_match_type_dest_src_ipv4_address_dest_src_ipv4_address_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_match_route_type_ipv4_ipv4_ip_route_match_type_dest_src_ipv4_address_dest_src_ipv4_address_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_match_route_type_ipv4_ipv4_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/match/route-type/ipv4/ipv4
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_match_route_type_ipv4_ipv4_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_match_route_type_ipv4_ipv4_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_match_route_type_ipv4_ipv4_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_match_route_type_ipv6_ipv6_ip_route_match_type_dest_ipv6_address_dest_ipv6_prefix_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/match/route-type/ipv6/ipv6/ip-route-match-type/dest-ipv6-address/dest-ipv6-prefix
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_match_route_type_ipv6_ipv6_ip_route_match_type_dest_ipv6_address_dest_ipv6_prefix_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_match_route_type_ipv6_ipv6_ip_route_match_type_dest_ipv6_address_dest_ipv6_prefix_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_match_route_type_ipv6_ipv6_ip_route_match_type_dest_ipv6_address_dest_ipv6_prefix_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_match_route_type_ipv6_ipv6_ip_route_match_type_src_ipv6_address_src_ipv6_prefix_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/match/route-type/ipv6/ipv6/ip-route-match-type/src-ipv6-address/src-ipv6-prefix
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_match_route_type_ipv6_ipv6_ip_route_match_type_src_ipv6_address_src_ipv6_prefix_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_match_route_type_ipv6_ipv6_ip_route_match_type_src_ipv6_address_src_ipv6_prefix_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_match_route_type_ipv6_ipv6_ip_route_match_type_src_ipv6_address_src_ipv6_prefix_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_match_route_type_ipv6_ipv6_ip_route_match_type_dest_src_ipv6_address_dest_src_ipv6_address_dest_ipv6_prefix_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/match/route-type/ipv6/ipv6/ip-route-match-type/dest-src-ipv6-address/dest-src-ipv6-address/dest-ipv6-prefix
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_match_route_type_ipv6_ipv6_ip_route_match_type_dest_src_ipv6_address_dest_src_ipv6_address_dest_ipv6_prefix_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_match_route_type_ipv6_ipv6_ip_route_match_type_dest_src_ipv6_address_dest_src_ipv6_address_dest_ipv6_prefix_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_match_route_type_ipv6_ipv6_ip_route_match_type_dest_src_ipv6_address_dest_src_ipv6_address_dest_ipv6_prefix_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_match_route_type_ipv6_ipv6_ip_route_match_type_dest_src_ipv6_address_dest_src_ipv6_address_src_ipv6_prefix_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/match/route-type/ipv6/ipv6/ip-route-match-type/dest-src-ipv6-address/dest-src-ipv6-address/src-ipv6-prefix
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_match_route_type_ipv6_ipv6_ip_route_match_type_dest_src_ipv6_address_dest_src_ipv6_address_src_ipv6_prefix_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_match_route_type_ipv6_ipv6_ip_route_match_type_dest_src_ipv6_address_dest_src_ipv6_address_src_ipv6_prefix_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_match_route_type_ipv6_ipv6_ip_route_match_type_dest_src_ipv6_address_dest_src_ipv6_address_src_ipv6_prefix_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_match_route_type_ipv6_ipv6_ip_route_match_type_dest_src_ipv6_address_dest_src_ipv6_address_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/match/route-type/ipv6/ipv6/ip-route-match-type/dest-src-ipv6-address/dest-src-ipv6-address
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_match_route_type_ipv6_ipv6_ip_route_match_type_dest_src_ipv6_address_dest_src_ipv6_address_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_match_route_type_ipv6_ipv6_ip_route_match_type_dest_src_ipv6_address_dest_src_ipv6_address_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_match_route_type_ipv6_ipv6_ip_route_match_type_dest_src_ipv6_address_dest_src_ipv6_address_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_match_route_type_ipv6_ipv6_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/match/route-type/ipv6/ipv6
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_match_route_type_ipv6_ipv6_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_match_route_type_ipv6_ipv6_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_match_route_type_ipv6_ipv6_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_match_route_type_mpls_route_mpls_label_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/match/route-type/mpls-route/mpls-label
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_match_route_type_mpls_route_mpls_label_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_match_route_type_mpls_route_mpls_label_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_match_route_type_mpls_route_mpls_label_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_match_route_type_mac_route_mac_address_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/match/route-type/mac-route/mac-address
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_match_route_type_mac_route_mac_address_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_match_route_type_mac_route_mac_address_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_match_route_type_mac_route_mac_address_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_match_route_type_interface_route_interface_identifier_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/match/route-type/interface-route/interface-identifier
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_match_route_type_interface_route_interface_identifier_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_match_route_type_interface_route_interface_identifier_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_match_route_type_interface_route_interface_identifier_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_match_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/match
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_match_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_match_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_match_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_id_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-id
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_id_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_id_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_id_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_sharing_flag_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/sharing-flag
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_sharing_flag_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_sharing_flag_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_sharing_flag_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_special_nexthop_special_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/special-nexthop/special
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_special_nexthop_special_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_special_nexthop_special_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_special_nexthop_special_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_egress_interface_nexthop_outgoing_interface_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/egress-interface-nexthop/outgoing-interface
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_egress_interface_nexthop_outgoing_interface_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_egress_interface_nexthop_outgoing_interface_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_egress_interface_nexthop_outgoing_interface_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_ipv4_address_nexthop_ipv4_address_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/ipv4-address-nexthop/ipv4-address
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_ipv4_address_nexthop_ipv4_address_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_ipv4_address_nexthop_ipv4_address_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_ipv4_address_nexthop_ipv4_address_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_ipv6_address_nexthop_ipv6_address_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/ipv6-address-nexthop/ipv6-address
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_ipv6_address_nexthop_ipv6_address_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_ipv6_address_nexthop_ipv6_address_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_ipv6_address_nexthop_ipv6_address_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_egress_interface_ipv4_nexthop_egress_interface_ipv4_address_outgoing_interface_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/egress-interface-ipv4-nexthop/egress-interface-ipv4-address/outgoing-interface
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_egress_interface_ipv4_nexthop_egress_interface_ipv4_address_outgoing_interface_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_egress_interface_ipv4_nexthop_egress_interface_ipv4_address_outgoing_interface_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_egress_interface_ipv4_nexthop_egress_interface_ipv4_address_outgoing_interface_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_egress_interface_ipv4_nexthop_egress_interface_ipv4_address_ipv4_address_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/egress-interface-ipv4-nexthop/egress-interface-ipv4-address/ipv4-address
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_egress_interface_ipv4_nexthop_egress_interface_ipv4_address_ipv4_address_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_egress_interface_ipv4_nexthop_egress_interface_ipv4_address_ipv4_address_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_egress_interface_ipv4_nexthop_egress_interface_ipv4_address_ipv4_address_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_egress_interface_ipv4_nexthop_egress_interface_ipv4_address_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/egress-interface-ipv4-nexthop/egress-interface-ipv4-address
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_egress_interface_ipv4_nexthop_egress_interface_ipv4_address_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_egress_interface_ipv4_nexthop_egress_interface_ipv4_address_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_egress_interface_ipv4_nexthop_egress_interface_ipv4_address_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_egress_interface_ipv6_nexthop_egress_interface_ipv6_address_outgoing_interface_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/egress-interface-ipv6-nexthop/egress-interface-ipv6-address/outgoing-interface
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_egress_interface_ipv6_nexthop_egress_interface_ipv6_address_outgoing_interface_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_egress_interface_ipv6_nexthop_egress_interface_ipv6_address_outgoing_interface_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_egress_interface_ipv6_nexthop_egress_interface_ipv6_address_outgoing_interface_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_egress_interface_ipv6_nexthop_egress_interface_ipv6_address_ipv6_address_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/egress-interface-ipv6-nexthop/egress-interface-ipv6-address/ipv6-address
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_egress_interface_ipv6_nexthop_egress_interface_ipv6_address_ipv6_address_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_egress_interface_ipv6_nexthop_egress_interface_ipv6_address_ipv6_address_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_egress_interface_ipv6_nexthop_egress_interface_ipv6_address_ipv6_address_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_egress_interface_ipv6_nexthop_egress_interface_ipv6_address_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/egress-interface-ipv6-nexthop/egress-interface-ipv6-address
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_egress_interface_ipv6_nexthop_egress_interface_ipv6_address_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_egress_interface_ipv6_nexthop_egress_interface_ipv6_address_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_egress_interface_ipv6_nexthop_egress_interface_ipv6_address_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_egress_interface_mac_nexthop_egress_interface_mac_address_outgoing_interface_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/egress-interface-mac-nexthop/egress-interface-mac-address/outgoing-interface
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_egress_interface_mac_nexthop_egress_interface_mac_address_outgoing_interface_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_egress_interface_mac_nexthop_egress_interface_mac_address_outgoing_interface_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_egress_interface_mac_nexthop_egress_interface_mac_address_outgoing_interface_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_egress_interface_mac_nexthop_egress_interface_mac_address_ieee_mac_address_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/egress-interface-mac-nexthop/egress-interface-mac-address/ieee-mac-address
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_egress_interface_mac_nexthop_egress_interface_mac_address_ieee_mac_address_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_egress_interface_mac_nexthop_egress_interface_mac_address_ieee_mac_address_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_egress_interface_mac_nexthop_egress_interface_mac_address_ieee_mac_address_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_egress_interface_mac_nexthop_egress_interface_mac_address_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/egress-interface-mac-nexthop/egress-interface-mac-address
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_egress_interface_mac_nexthop_egress_interface_mac_address_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_egress_interface_mac_nexthop_egress_interface_mac_address_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_egress_interface_mac_nexthop_egress_interface_mac_address_edit */


#ifdef u_ietf_i2rs_rib_F_nexthop_tunnel

#ifdef u_ietf_i2rs_rib_F_ipv4_tunnel

/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_ipv4_ipv4_header_src_ipv4_address_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/ipv4/ipv4-header/src-ipv4-address
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_ipv4_ipv4_header_src_ipv4_address_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_ipv4_ipv4_header_src_ipv4_address_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_ipv4_ipv4_header_src_ipv4_address_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_ipv4_ipv4_header_dest_ipv4_address_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/ipv4/ipv4-header/dest-ipv4-address
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_ipv4_ipv4_header_dest_ipv4_address_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_ipv4_ipv4_header_dest_ipv4_address_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_ipv4_ipv4_header_dest_ipv4_address_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_ipv4_ipv4_header_protocol_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/ipv4/ipv4-header/protocol
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_ipv4_ipv4_header_protocol_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_ipv4_ipv4_header_protocol_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_ipv4_ipv4_header_protocol_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_ipv4_ipv4_header_ttl_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/ipv4/ipv4-header/ttl
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_ipv4_ipv4_header_ttl_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_ipv4_ipv4_header_ttl_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_ipv4_ipv4_header_ttl_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_ipv4_ipv4_header_dscp_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/ipv4/ipv4-header/dscp
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_ipv4_ipv4_header_dscp_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_ipv4_ipv4_header_dscp_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_ipv4_ipv4_header_dscp_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_ipv4_ipv4_header_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/ipv4/ipv4-header
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_ipv4_ipv4_header_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_ipv4_ipv4_header_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_ipv4_ipv4_header_edit */

#endif /* u_ietf_i2rs_rib_F_ipv4_tunnel */

#ifdef u_ietf_i2rs_rib_F_ipv6_tunnel

/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_ipv6_ipv6_header_src_ipv6_address_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/ipv6/ipv6-header/src-ipv6-address
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_ipv6_ipv6_header_src_ipv6_address_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_ipv6_ipv6_header_src_ipv6_address_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_ipv6_ipv6_header_src_ipv6_address_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_ipv6_ipv6_header_dest_ipv6_address_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/ipv6/ipv6-header/dest-ipv6-address
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_ipv6_ipv6_header_dest_ipv6_address_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_ipv6_ipv6_header_dest_ipv6_address_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_ipv6_ipv6_header_dest_ipv6_address_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_ipv6_ipv6_header_next_header_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/ipv6/ipv6-header/next-header
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_ipv6_ipv6_header_next_header_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_ipv6_ipv6_header_next_header_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_ipv6_ipv6_header_next_header_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_ipv6_ipv6_header_traffic_class_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/ipv6/ipv6-header/traffic-class
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_ipv6_ipv6_header_traffic_class_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_ipv6_ipv6_header_traffic_class_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_ipv6_ipv6_header_traffic_class_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_ipv6_ipv6_header_flow_label_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/ipv6/ipv6-header/flow-label
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_ipv6_ipv6_header_flow_label_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_ipv6_ipv6_header_flow_label_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_ipv6_ipv6_header_flow_label_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_ipv6_ipv6_header_hop_limit_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/ipv6/ipv6-header/hop-limit
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_ipv6_ipv6_header_hop_limit_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_ipv6_ipv6_header_hop_limit_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_ipv6_ipv6_header_hop_limit_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_ipv6_ipv6_header_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/ipv6/ipv6-header
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_ipv6_ipv6_header_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_ipv6_ipv6_header_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_ipv6_ipv6_header_edit */

#endif /* u_ietf_i2rs_rib_F_ipv6_tunnel */

#ifdef u_ietf_i2rs_rib_F_mpls_tunnel

/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_mpls_mpls_header_label_operations_label_oper_id_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/mpls/mpls-header/label-operations/label-oper-id
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_mpls_mpls_header_label_operations_label_oper_id_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_mpls_mpls_header_label_operations_label_oper_id_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_mpls_mpls_header_label_operations_label_oper_id_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_mpls_mpls_header_label_operations_label_actions_label_push_label_push_label_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/mpls/mpls-header/label-operations/label-actions/label-push/label-push/label
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_mpls_mpls_header_label_operations_label_actions_label_push_label_push_label_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_mpls_mpls_header_label_operations_label_actions_label_push_label_push_label_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_mpls_mpls_header_label_operations_label_actions_label_push_label_push_label_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_mpls_mpls_header_label_operations_label_actions_label_push_label_push_s_bit_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/mpls/mpls-header/label-operations/label-actions/label-push/label-push/s-bit
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_mpls_mpls_header_label_operations_label_actions_label_push_label_push_s_bit_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_mpls_mpls_header_label_operations_label_actions_label_push_label_push_s_bit_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_mpls_mpls_header_label_operations_label_actions_label_push_label_push_s_bit_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_mpls_mpls_header_label_operations_label_actions_label_push_label_push_tc_value_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/mpls/mpls-header/label-operations/label-actions/label-push/label-push/tc-value
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_mpls_mpls_header_label_operations_label_actions_label_push_label_push_tc_value_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_mpls_mpls_header_label_operations_label_actions_label_push_label_push_tc_value_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_mpls_mpls_header_label_operations_label_actions_label_push_label_push_tc_value_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_mpls_mpls_header_label_operations_label_actions_label_push_label_push_ttl_value_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/mpls/mpls-header/label-operations/label-actions/label-push/label-push/ttl-value
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_mpls_mpls_header_label_operations_label_actions_label_push_label_push_ttl_value_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_mpls_mpls_header_label_operations_label_actions_label_push_label_push_ttl_value_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_mpls_mpls_header_label_operations_label_actions_label_push_label_push_ttl_value_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_mpls_mpls_header_label_operations_label_actions_label_push_label_push_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/mpls/mpls-header/label-operations/label-actions/label-push/label-push
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_mpls_mpls_header_label_operations_label_actions_label_push_label_push_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_mpls_mpls_header_label_operations_label_actions_label_push_label_push_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_mpls_mpls_header_label_operations_label_actions_label_push_label_push_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_mpls_mpls_header_label_operations_label_actions_label_swap_label_swap_in_label_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/mpls/mpls-header/label-operations/label-actions/label-swap/label-swap/in-label
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_mpls_mpls_header_label_operations_label_actions_label_swap_label_swap_in_label_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_mpls_mpls_header_label_operations_label_actions_label_swap_label_swap_in_label_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_mpls_mpls_header_label_operations_label_actions_label_swap_label_swap_in_label_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_mpls_mpls_header_label_operations_label_actions_label_swap_label_swap_out_label_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/mpls/mpls-header/label-operations/label-actions/label-swap/label-swap/out-label
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_mpls_mpls_header_label_operations_label_actions_label_swap_label_swap_out_label_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_mpls_mpls_header_label_operations_label_actions_label_swap_label_swap_out_label_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_mpls_mpls_header_label_operations_label_actions_label_swap_label_swap_out_label_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_mpls_mpls_header_label_operations_label_actions_label_swap_label_swap_ttl_action_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/mpls/mpls-header/label-operations/label-actions/label-swap/label-swap/ttl-action
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_mpls_mpls_header_label_operations_label_actions_label_swap_label_swap_ttl_action_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_mpls_mpls_header_label_operations_label_actions_label_swap_label_swap_ttl_action_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_mpls_mpls_header_label_operations_label_actions_label_swap_label_swap_ttl_action_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_mpls_mpls_header_label_operations_label_actions_label_swap_label_swap_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/mpls/mpls-header/label-operations/label-actions/label-swap/label-swap
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_mpls_mpls_header_label_operations_label_actions_label_swap_label_swap_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_mpls_mpls_header_label_operations_label_actions_label_swap_label_swap_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_mpls_mpls_header_label_operations_label_actions_label_swap_label_swap_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_mpls_mpls_header_label_operations_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/mpls/mpls-header/label-operations
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_mpls_mpls_header_label_operations_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_mpls_mpls_header_label_operations_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_mpls_mpls_header_label_operations_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_mpls_mpls_header_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/mpls/mpls-header
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_mpls_mpls_header_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_mpls_mpls_header_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_mpls_mpls_header_edit */

#endif /* u_ietf_i2rs_rib_F_mpls_tunnel */

#ifdef u_ietf_i2rs_rib_F_gre_tunnel

/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_gre_gre_header_dest_address_type_ipv4_ipv4_dest_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/gre/gre-header/dest-address-type/ipv4/ipv4-dest
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_gre_gre_header_dest_address_type_ipv4_ipv4_dest_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_gre_gre_header_dest_address_type_ipv4_ipv4_dest_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_gre_gre_header_dest_address_type_ipv4_ipv4_dest_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_gre_gre_header_dest_address_type_ipv6_ipv6_dest_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/gre/gre-header/dest-address-type/ipv6/ipv6-dest
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_gre_gre_header_dest_address_type_ipv6_ipv6_dest_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_gre_gre_header_dest_address_type_ipv6_ipv6_dest_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_gre_gre_header_dest_address_type_ipv6_ipv6_dest_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_gre_gre_header_protocol_type_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/gre/gre-header/protocol-type
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_gre_gre_header_protocol_type_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_gre_gre_header_protocol_type_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_gre_gre_header_protocol_type_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_gre_gre_header_key_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/gre/gre-header/key
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_gre_gre_header_key_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_gre_gre_header_key_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_gre_gre_header_key_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_gre_gre_header_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/gre/gre-header
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_gre_gre_header_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_gre_gre_header_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_gre_gre_header_edit */

#endif /* u_ietf_i2rs_rib_F_gre_tunnel */

#ifdef u_ietf_i2rs_rib_F_nvgre_tunnel

/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_nvgre_nvgre_header_nvgre_type_ipv4_src_ipv4_address_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/nvgre/nvgre-header/nvgre-type/ipv4/src-ipv4-address
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_nvgre_nvgre_header_nvgre_type_ipv4_src_ipv4_address_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_nvgre_nvgre_header_nvgre_type_ipv4_src_ipv4_address_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_nvgre_nvgre_header_nvgre_type_ipv4_src_ipv4_address_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_nvgre_nvgre_header_nvgre_type_ipv4_dest_ipv4_address_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/nvgre/nvgre-header/nvgre-type/ipv4/dest-ipv4-address
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_nvgre_nvgre_header_nvgre_type_ipv4_dest_ipv4_address_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_nvgre_nvgre_header_nvgre_type_ipv4_dest_ipv4_address_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_nvgre_nvgre_header_nvgre_type_ipv4_dest_ipv4_address_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_nvgre_nvgre_header_nvgre_type_ipv4_protocol_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/nvgre/nvgre-header/nvgre-type/ipv4/protocol
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_nvgre_nvgre_header_nvgre_type_ipv4_protocol_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_nvgre_nvgre_header_nvgre_type_ipv4_protocol_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_nvgre_nvgre_header_nvgre_type_ipv4_protocol_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_nvgre_nvgre_header_nvgre_type_ipv4_ttl_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/nvgre/nvgre-header/nvgre-type/ipv4/ttl
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_nvgre_nvgre_header_nvgre_type_ipv4_ttl_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_nvgre_nvgre_header_nvgre_type_ipv4_ttl_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_nvgre_nvgre_header_nvgre_type_ipv4_ttl_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_nvgre_nvgre_header_nvgre_type_ipv4_dscp_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/nvgre/nvgre-header/nvgre-type/ipv4/dscp
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_nvgre_nvgre_header_nvgre_type_ipv4_dscp_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_nvgre_nvgre_header_nvgre_type_ipv4_dscp_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_nvgre_nvgre_header_nvgre_type_ipv4_dscp_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_nvgre_nvgre_header_nvgre_type_ipv6_src_ipv6_address_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/nvgre/nvgre-header/nvgre-type/ipv6/src-ipv6-address
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_nvgre_nvgre_header_nvgre_type_ipv6_src_ipv6_address_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_nvgre_nvgre_header_nvgre_type_ipv6_src_ipv6_address_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_nvgre_nvgre_header_nvgre_type_ipv6_src_ipv6_address_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_nvgre_nvgre_header_nvgre_type_ipv6_dest_ipv6_address_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/nvgre/nvgre-header/nvgre-type/ipv6/dest-ipv6-address
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_nvgre_nvgre_header_nvgre_type_ipv6_dest_ipv6_address_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_nvgre_nvgre_header_nvgre_type_ipv6_dest_ipv6_address_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_nvgre_nvgre_header_nvgre_type_ipv6_dest_ipv6_address_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_nvgre_nvgre_header_nvgre_type_ipv6_next_header_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/nvgre/nvgre-header/nvgre-type/ipv6/next-header
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_nvgre_nvgre_header_nvgre_type_ipv6_next_header_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_nvgre_nvgre_header_nvgre_type_ipv6_next_header_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_nvgre_nvgre_header_nvgre_type_ipv6_next_header_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_nvgre_nvgre_header_nvgre_type_ipv6_traffic_class_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/nvgre/nvgre-header/nvgre-type/ipv6/traffic-class
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_nvgre_nvgre_header_nvgre_type_ipv6_traffic_class_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_nvgre_nvgre_header_nvgre_type_ipv6_traffic_class_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_nvgre_nvgre_header_nvgre_type_ipv6_traffic_class_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_nvgre_nvgre_header_nvgre_type_ipv6_flow_label_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/nvgre/nvgre-header/nvgre-type/ipv6/flow-label
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_nvgre_nvgre_header_nvgre_type_ipv6_flow_label_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_nvgre_nvgre_header_nvgre_type_ipv6_flow_label_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_nvgre_nvgre_header_nvgre_type_ipv6_flow_label_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_nvgre_nvgre_header_nvgre_type_ipv6_hop_limit_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/nvgre/nvgre-header/nvgre-type/ipv6/hop-limit
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_nvgre_nvgre_header_nvgre_type_ipv6_hop_limit_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_nvgre_nvgre_header_nvgre_type_ipv6_hop_limit_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_nvgre_nvgre_header_nvgre_type_ipv6_hop_limit_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_nvgre_nvgre_header_virtual_subnet_id_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/nvgre/nvgre-header/virtual-subnet-id
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_nvgre_nvgre_header_virtual_subnet_id_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_nvgre_nvgre_header_virtual_subnet_id_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_nvgre_nvgre_header_virtual_subnet_id_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_nvgre_nvgre_header_flow_id_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/nvgre/nvgre-header/flow-id
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_nvgre_nvgre_header_flow_id_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_nvgre_nvgre_header_flow_id_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_nvgre_nvgre_header_flow_id_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_nvgre_nvgre_header_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/nvgre/nvgre-header
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_nvgre_nvgre_header_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_nvgre_nvgre_header_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_nvgre_nvgre_header_edit */

#endif /* u_ietf_i2rs_rib_F_nvgre_tunnel */

#ifdef u_ietf_i2rs_rib_F_vxlan_tunnel

/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_vxlan_vxlan_header_vxlan_type_ipv4_src_ipv4_address_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/vxlan/vxlan-header/vxlan-type/ipv4/src-ipv4-address
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_vxlan_vxlan_header_vxlan_type_ipv4_src_ipv4_address_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_vxlan_vxlan_header_vxlan_type_ipv4_src_ipv4_address_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_vxlan_vxlan_header_vxlan_type_ipv4_src_ipv4_address_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_vxlan_vxlan_header_vxlan_type_ipv4_dest_ipv4_address_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/vxlan/vxlan-header/vxlan-type/ipv4/dest-ipv4-address
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_vxlan_vxlan_header_vxlan_type_ipv4_dest_ipv4_address_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_vxlan_vxlan_header_vxlan_type_ipv4_dest_ipv4_address_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_vxlan_vxlan_header_vxlan_type_ipv4_dest_ipv4_address_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_vxlan_vxlan_header_vxlan_type_ipv4_protocol_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/vxlan/vxlan-header/vxlan-type/ipv4/protocol
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_vxlan_vxlan_header_vxlan_type_ipv4_protocol_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_vxlan_vxlan_header_vxlan_type_ipv4_protocol_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_vxlan_vxlan_header_vxlan_type_ipv4_protocol_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_vxlan_vxlan_header_vxlan_type_ipv4_ttl_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/vxlan/vxlan-header/vxlan-type/ipv4/ttl
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_vxlan_vxlan_header_vxlan_type_ipv4_ttl_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_vxlan_vxlan_header_vxlan_type_ipv4_ttl_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_vxlan_vxlan_header_vxlan_type_ipv4_ttl_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_vxlan_vxlan_header_vxlan_type_ipv4_dscp_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/vxlan/vxlan-header/vxlan-type/ipv4/dscp
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_vxlan_vxlan_header_vxlan_type_ipv4_dscp_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_vxlan_vxlan_header_vxlan_type_ipv4_dscp_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_vxlan_vxlan_header_vxlan_type_ipv4_dscp_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_vxlan_vxlan_header_vxlan_type_ipv6_src_ipv6_address_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/vxlan/vxlan-header/vxlan-type/ipv6/src-ipv6-address
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_vxlan_vxlan_header_vxlan_type_ipv6_src_ipv6_address_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_vxlan_vxlan_header_vxlan_type_ipv6_src_ipv6_address_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_vxlan_vxlan_header_vxlan_type_ipv6_src_ipv6_address_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_vxlan_vxlan_header_vxlan_type_ipv6_dest_ipv6_address_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/vxlan/vxlan-header/vxlan-type/ipv6/dest-ipv6-address
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_vxlan_vxlan_header_vxlan_type_ipv6_dest_ipv6_address_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_vxlan_vxlan_header_vxlan_type_ipv6_dest_ipv6_address_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_vxlan_vxlan_header_vxlan_type_ipv6_dest_ipv6_address_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_vxlan_vxlan_header_vxlan_type_ipv6_next_header_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/vxlan/vxlan-header/vxlan-type/ipv6/next-header
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_vxlan_vxlan_header_vxlan_type_ipv6_next_header_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_vxlan_vxlan_header_vxlan_type_ipv6_next_header_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_vxlan_vxlan_header_vxlan_type_ipv6_next_header_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_vxlan_vxlan_header_vxlan_type_ipv6_traffic_class_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/vxlan/vxlan-header/vxlan-type/ipv6/traffic-class
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_vxlan_vxlan_header_vxlan_type_ipv6_traffic_class_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_vxlan_vxlan_header_vxlan_type_ipv6_traffic_class_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_vxlan_vxlan_header_vxlan_type_ipv6_traffic_class_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_vxlan_vxlan_header_vxlan_type_ipv6_flow_label_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/vxlan/vxlan-header/vxlan-type/ipv6/flow-label
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_vxlan_vxlan_header_vxlan_type_ipv6_flow_label_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_vxlan_vxlan_header_vxlan_type_ipv6_flow_label_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_vxlan_vxlan_header_vxlan_type_ipv6_flow_label_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_vxlan_vxlan_header_vxlan_type_ipv6_hop_limit_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/vxlan/vxlan-header/vxlan-type/ipv6/hop-limit
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_vxlan_vxlan_header_vxlan_type_ipv6_hop_limit_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_vxlan_vxlan_header_vxlan_type_ipv6_hop_limit_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_vxlan_vxlan_header_vxlan_type_ipv6_hop_limit_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_vxlan_vxlan_header_vxlan_identifier_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/vxlan/vxlan-header/vxlan-identifier
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_vxlan_vxlan_header_vxlan_identifier_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_vxlan_vxlan_header_vxlan_identifier_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_vxlan_vxlan_header_vxlan_identifier_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_vxlan_vxlan_header_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/vxlan/vxlan-header
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_vxlan_vxlan_header_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_vxlan_vxlan_header_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_vxlan_vxlan_header_edit */

#endif /* u_ietf_i2rs_rib_F_vxlan_tunnel */

/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_edit */

#endif /* u_ietf_i2rs_rib_F_nexthop_tunnel */

#ifdef u_ietf_i2rs_rib_F_nexthop_tunnel

#ifdef u_ietf_i2rs_rib_F_ipv4_tunnel

/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_decap_nexthop_tunnel_decap_tunnel_type_ipv4_ipv4_decap_ipv4_decap_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-decap-nexthop/tunnel-decap/tunnel-type/ipv4/ipv4-decap/ipv4-decap
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_decap_nexthop_tunnel_decap_tunnel_type_ipv4_ipv4_decap_ipv4_decap_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_decap_nexthop_tunnel_decap_tunnel_type_ipv4_ipv4_decap_ipv4_decap_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_decap_nexthop_tunnel_decap_tunnel_type_ipv4_ipv4_decap_ipv4_decap_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_decap_nexthop_tunnel_decap_tunnel_type_ipv4_ipv4_decap_ttl_action_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-decap-nexthop/tunnel-decap/tunnel-type/ipv4/ipv4-decap/ttl-action
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_decap_nexthop_tunnel_decap_tunnel_type_ipv4_ipv4_decap_ttl_action_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_decap_nexthop_tunnel_decap_tunnel_type_ipv4_ipv4_decap_ttl_action_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_decap_nexthop_tunnel_decap_tunnel_type_ipv4_ipv4_decap_ttl_action_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_decap_nexthop_tunnel_decap_tunnel_type_ipv4_ipv4_decap_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-decap-nexthop/tunnel-decap/tunnel-type/ipv4/ipv4-decap
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_decap_nexthop_tunnel_decap_tunnel_type_ipv4_ipv4_decap_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_decap_nexthop_tunnel_decap_tunnel_type_ipv4_ipv4_decap_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_decap_nexthop_tunnel_decap_tunnel_type_ipv4_ipv4_decap_edit */

#endif /* u_ietf_i2rs_rib_F_ipv4_tunnel */

#ifdef u_ietf_i2rs_rib_F_ipv6_tunnel

/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_decap_nexthop_tunnel_decap_tunnel_type_ipv6_ipv6_decap_ipv6_decap_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-decap-nexthop/tunnel-decap/tunnel-type/ipv6/ipv6-decap/ipv6-decap
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_decap_nexthop_tunnel_decap_tunnel_type_ipv6_ipv6_decap_ipv6_decap_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_decap_nexthop_tunnel_decap_tunnel_type_ipv6_ipv6_decap_ipv6_decap_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_decap_nexthop_tunnel_decap_tunnel_type_ipv6_ipv6_decap_ipv6_decap_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_decap_nexthop_tunnel_decap_tunnel_type_ipv6_ipv6_decap_hop_limit_action_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-decap-nexthop/tunnel-decap/tunnel-type/ipv6/ipv6-decap/hop-limit-action
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_decap_nexthop_tunnel_decap_tunnel_type_ipv6_ipv6_decap_hop_limit_action_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_decap_nexthop_tunnel_decap_tunnel_type_ipv6_ipv6_decap_hop_limit_action_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_decap_nexthop_tunnel_decap_tunnel_type_ipv6_ipv6_decap_hop_limit_action_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_decap_nexthop_tunnel_decap_tunnel_type_ipv6_ipv6_decap_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-decap-nexthop/tunnel-decap/tunnel-type/ipv6/ipv6-decap
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_decap_nexthop_tunnel_decap_tunnel_type_ipv6_ipv6_decap_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_decap_nexthop_tunnel_decap_tunnel_type_ipv6_ipv6_decap_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_decap_nexthop_tunnel_decap_tunnel_type_ipv6_ipv6_decap_edit */

#endif /* u_ietf_i2rs_rib_F_ipv6_tunnel */

#ifdef u_ietf_i2rs_rib_F_mpls_tunnel

/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_decap_nexthop_tunnel_decap_tunnel_type_mpls_label_pop_label_pop_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-decap-nexthop/tunnel-decap/tunnel-type/mpls/label-pop/label-pop
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_decap_nexthop_tunnel_decap_tunnel_type_mpls_label_pop_label_pop_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_decap_nexthop_tunnel_decap_tunnel_type_mpls_label_pop_label_pop_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_decap_nexthop_tunnel_decap_tunnel_type_mpls_label_pop_label_pop_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_decap_nexthop_tunnel_decap_tunnel_type_mpls_label_pop_ttl_action_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-decap-nexthop/tunnel-decap/tunnel-type/mpls/label-pop/ttl-action
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_decap_nexthop_tunnel_decap_tunnel_type_mpls_label_pop_ttl_action_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_decap_nexthop_tunnel_decap_tunnel_type_mpls_label_pop_ttl_action_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_decap_nexthop_tunnel_decap_tunnel_type_mpls_label_pop_ttl_action_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_decap_nexthop_tunnel_decap_tunnel_type_mpls_label_pop_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-decap-nexthop/tunnel-decap/tunnel-type/mpls/label-pop
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_decap_nexthop_tunnel_decap_tunnel_type_mpls_label_pop_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_decap_nexthop_tunnel_decap_tunnel_type_mpls_label_pop_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_decap_nexthop_tunnel_decap_tunnel_type_mpls_label_pop_edit */

#endif /* u_ietf_i2rs_rib_F_mpls_tunnel */

/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_decap_nexthop_tunnel_decap_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-decap-nexthop/tunnel-decap
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_decap_nexthop_tunnel_decap_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_decap_nexthop_tunnel_decap_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_decap_nexthop_tunnel_decap_edit */

#endif /* u_ietf_i2rs_rib_F_nexthop_tunnel */

#ifdef u_ietf_i2rs_rib_F_nexthop_tunnel

/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_logical_tunnel_nexthop_logical_tunnel_tunnel_type_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/logical-tunnel-nexthop/logical-tunnel/tunnel-type
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_logical_tunnel_nexthop_logical_tunnel_tunnel_type_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_logical_tunnel_nexthop_logical_tunnel_tunnel_type_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_logical_tunnel_nexthop_logical_tunnel_tunnel_type_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_logical_tunnel_nexthop_logical_tunnel_tunnel_name_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/logical-tunnel-nexthop/logical-tunnel/tunnel-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_logical_tunnel_nexthop_logical_tunnel_tunnel_name_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_logical_tunnel_nexthop_logical_tunnel_tunnel_name_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_logical_tunnel_nexthop_logical_tunnel_tunnel_name_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_logical_tunnel_nexthop_logical_tunnel_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/logical-tunnel-nexthop/logical-tunnel
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_logical_tunnel_nexthop_logical_tunnel_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_logical_tunnel_nexthop_logical_tunnel_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_logical_tunnel_nexthop_logical_tunnel_edit */

#endif /* u_ietf_i2rs_rib_F_nexthop_tunnel */

/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_rib_name_nexthop_rib_name_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/rib-name-nexthop/rib-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_rib_name_nexthop_rib_name_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_rib_name_nexthop_rib_name_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_rib_name_nexthop_rib_name_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_nexthop_identifier_nexthop_ref_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/nexthop-identifier/nexthop-ref
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_nexthop_identifier_nexthop_ref_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_nexthop_identifier_nexthop_ref_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_nexthop_identifier_nexthop_ref_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_edit */


#ifdef u_ietf_i2rs_rib_F_nexthop_chain

/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_chain_nexthop_chain_nexthop_list_nexthop_member_id_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-chain/nexthop-chain/nexthop-list/nexthop-member-id
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_chain_nexthop_chain_nexthop_list_nexthop_member_id_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_chain_nexthop_chain_nexthop_list_nexthop_member_id_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_chain_nexthop_chain_nexthop_list_nexthop_member_id_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_chain_nexthop_chain_nexthop_list_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-chain/nexthop-chain/nexthop-list
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_chain_nexthop_chain_nexthop_list_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_chain_nexthop_chain_nexthop_list_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_chain_nexthop_chain_nexthop_list_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_chain_nexthop_chain_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-chain/nexthop-chain
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_chain_nexthop_chain_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_chain_nexthop_chain_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_chain_nexthop_chain_edit */

#endif /* u_ietf_i2rs_rib_F_nexthop_chain */

#ifdef u_ietf_i2rs_rib_F_nexthop_replicates

/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_replicates_nexthop_replicates_nexthop_list_nexthop_member_id_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-replicates/nexthop-replicates/nexthop-list/nexthop-member-id
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_replicates_nexthop_replicates_nexthop_list_nexthop_member_id_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_replicates_nexthop_replicates_nexthop_list_nexthop_member_id_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_replicates_nexthop_replicates_nexthop_list_nexthop_member_id_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_replicates_nexthop_replicates_nexthop_list_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-replicates/nexthop-replicates/nexthop-list
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_replicates_nexthop_replicates_nexthop_list_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_replicates_nexthop_replicates_nexthop_list_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_replicates_nexthop_replicates_nexthop_list_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_replicates_nexthop_replicates_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-replicates/nexthop-replicates
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_replicates_nexthop_replicates_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_replicates_nexthop_replicates_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_replicates_nexthop_replicates_edit */

#endif /* u_ietf_i2rs_rib_F_nexthop_replicates */

#ifdef u_ietf_i2rs_rib_F_nexthop_protection

/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_protection_nexthop_protection_nexthop_list_nexthop_member_id_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-protection/nexthop-protection/nexthop-list/nexthop-member-id
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_protection_nexthop_protection_nexthop_list_nexthop_member_id_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_protection_nexthop_protection_nexthop_list_nexthop_member_id_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_protection_nexthop_protection_nexthop_list_nexthop_member_id_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_protection_nexthop_protection_nexthop_list_nexthop_preference_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-protection/nexthop-protection/nexthop-list/nexthop-preference
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_protection_nexthop_protection_nexthop_list_nexthop_preference_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_protection_nexthop_protection_nexthop_list_nexthop_preference_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_protection_nexthop_protection_nexthop_list_nexthop_preference_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_protection_nexthop_protection_nexthop_list_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-protection/nexthop-protection/nexthop-list
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_protection_nexthop_protection_nexthop_list_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_protection_nexthop_protection_nexthop_list_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_protection_nexthop_protection_nexthop_list_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_protection_nexthop_protection_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-protection/nexthop-protection
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_protection_nexthop_protection_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_protection_nexthop_protection_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_protection_nexthop_protection_edit */

#endif /* u_ietf_i2rs_rib_F_nexthop_protection */

#ifdef u_ietf_i2rs_rib_F_nexthop_load_balance

/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_load_balance_nexthop_lb_nexthop_list_nexthop_member_id_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-load-balance/nexthop-lb/nexthop-list/nexthop-member-id
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_load_balance_nexthop_lb_nexthop_list_nexthop_member_id_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_load_balance_nexthop_lb_nexthop_list_nexthop_member_id_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_load_balance_nexthop_lb_nexthop_list_nexthop_member_id_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_load_balance_nexthop_lb_nexthop_list_nexthop_lb_weight_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-load-balance/nexthop-lb/nexthop-list/nexthop-lb-weight
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_load_balance_nexthop_lb_nexthop_list_nexthop_lb_weight_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_load_balance_nexthop_lb_nexthop_list_nexthop_lb_weight_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_load_balance_nexthop_lb_nexthop_list_nexthop_lb_weight_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_load_balance_nexthop_lb_nexthop_list_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-load-balance/nexthop-lb/nexthop-list
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_load_balance_nexthop_lb_nexthop_list_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_load_balance_nexthop_lb_nexthop_list_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_load_balance_nexthop_lb_nexthop_list_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_load_balance_nexthop_lb_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-load-balance/nexthop-lb
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_load_balance_nexthop_lb_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_load_balance_nexthop_lb_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_load_balance_nexthop_lb_edit */

#endif /* u_ietf_i2rs_rib_F_nexthop_load_balance */

/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/nexthop
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_edit */

/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_route_status_route_state_get
* 
* Get database object callback
* Path: /routing-instance/rib-list/route-list/route-status/route-state
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_route_status_route_state_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  const val_idref_t *route_state;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_route_status_route_state_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the route_state var here, change EMPTY_STRING */
  route_state = EMPTY_STRING;
  res = val_set_simval_obj(
    dstval,
    dstval->obj,
    route_state);

  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_route_status_route_state_get */

/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_route_status_route_installed_state_get
* 
* Get database object callback
* Path: /routing-instance/rib-list/route-list/route-status/route-installed-state
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_route_status_route_installed_state_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  const val_idref_t *route_installed_state;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_route_status_route_installed_state_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the route_installed_state var here, change EMPTY_STRING */
  route_installed_state = EMPTY_STRING;
  res = val_set_simval_obj(
    dstval,
    dstval->obj,
    route_installed_state);

  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_route_status_route_installed_state_get */

/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_route_status_route_reason_get
* 
* Get database object callback
* Path: /routing-instance/rib-list/route-list/route-status/route-reason
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_route_status_route_reason_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  const val_idref_t *route_reason;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_route_status_route_reason_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the route_reason var here, change EMPTY_STRING */
  route_reason = EMPTY_STRING;
  res = val_set_simval_obj(
    dstval,
    dstval->obj,
    route_reason);

  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_route_status_route_reason_get */

/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_route_status_mro
* 
* Make read-only child nodes
* Path: /routing-instance/rib-list/route-list/route-status
* 
* INPUTS:
*     parentval == the parent struct to use for new child nodes
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
  ietf_i2rs_rib_routing_instance_rib_list_route_list_route_status_mro (val_value_t *parentval)
{
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  

  /* add /routing-instance/rib-list/route-list/route-status/route-state */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_ietf_i2rs_rib_N_route_state,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_route_status_route_state_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /routing-instance/rib-list/route-list/route-status/route-installed-state */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_ietf_i2rs_rib_N_route_installed_state,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_route_status_route_installed_state_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /routing-instance/rib-list/route-list/route-status/route-reason */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_ietf_i2rs_rib_N_route_reason,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_route_status_route_reason_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_route_status_mro */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_route_status_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/route-status
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_route_status_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_route_status_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    if (res == NO_ERR && curval == NULL) {
      res = ietf_i2rs_rib_routing_instance_rib_list_route_list_route_status_mro(newval);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_route_status_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_route_attributes_route_preference_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/route-attributes/route-preference
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_route_attributes_route_preference_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_route_attributes_route_preference_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_route_attributes_route_preference_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_route_attributes_local_only_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/route-attributes/local-only
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_route_attributes_local_only_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_route_attributes_local_only_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_route_attributes_local_only_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_route_attributes_address_family_route_attributes_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/route-attributes/address-family-route-attributes
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_route_attributes_address_family_route_attributes_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_route_attributes_address_family_route_attributes_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_route_attributes_address_family_route_attributes_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_route_attributes_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/route-attributes
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_route_attributes_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_route_attributes_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_route_attributes_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_route_vendor_attributes_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list/route-vendor-attributes
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_route_vendor_attributes_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_route_vendor_attributes_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_route_vendor_attributes_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_route_list_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/route-list
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_route_list_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_route_list_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_route_list_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_nexthop_list_nexthop_member_id_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/nexthop-list/nexthop-member-id
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_nexthop_list_nexthop_member_id_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_nexthop_list_nexthop_member_id_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_nexthop_list_nexthop_member_id_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_nexthop_list_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list/nexthop-list
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_nexthop_list_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_nexthop_list_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_nexthop_list_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_rib_list_edit
* 
* Edit database object callback
* Path: /routing-instance/rib-list
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_rib_list_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_rib_list_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_rib_list_edit */


/********************************************************************
* FUNCTION ietf_i2rs_rib_routing_instance_edit
* 
* Edit database object callback
* Path: /routing-instance
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t ietf_i2rs_rib_routing_instance_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter ietf_i2rs_rib_routing_instance_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res == NO_ERR) {
      res = agt_check_cache(&routing_instance_val, newval, curval, editop);
    }
    
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* ietf_i2rs_rib_routing_instance_edit */


/********************************************************************
* FUNCTION y_ietf_i2rs_rib_rib_add_validate
* 
* RPC validation phase
* All YANG constraints have passed at this point.
* Add description-stmt checks in this function.
* 
* INPUTS:
*     see agt/agt_rpc.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t y_ietf_i2rs_rib_rib_add_validate (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  xml_node_t *methnode)
{
  status_t res = NO_ERR;
  val_value_t *errorval = NULL;

  val_value_t *name_val;
  const xmlChar *name;
  val_value_t *address_family_val;
  const val_idref_t *address_family;
  val_value_t *ip_rpf_check_val;
  boolean ip_rpf_check;

  name_val = val_find_child(
    msg->rpc_input,
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    y_ietf_i2rs_rib_N_name);
  if (name_val != NULL && name_val->res == NO_ERR) {
    name = VAL_STRING(name_val);
  }

  address_family_val = val_find_child(
    msg->rpc_input,
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    y_ietf_i2rs_rib_N_address_family);
  if (address_family_val != NULL && address_family_val->res == NO_ERR) {
    address_family = VAL_IDREF(address_family_val);
  }

  ip_rpf_check_val = val_find_child(
    msg->rpc_input,
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    y_ietf_i2rs_rib_N_ip_rpf_check);
  if (ip_rpf_check_val != NULL && ip_rpf_check_val->res == NO_ERR) {
    ip_rpf_check = VAL_BOOL(ip_rpf_check_val);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_OPERATION,
      res,
      methnode,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* y_ietf_i2rs_rib_rib_add_validate */


/********************************************************************
* FUNCTION y_ietf_i2rs_rib_rib_add_invoke
* 
* RPC invocation phase
* All constraints have passed at this point.
* Call device instrumentation code in this function.
* 
* INPUTS:
*     see agt/agt_rpc.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t y_ietf_i2rs_rib_rib_add_invoke (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  xml_node_t *methnode)
{
  status_t res = NO_ERR;

  val_value_t *name_val;
  const xmlChar *name;
  val_value_t *address_family_val;
  const val_idref_t *address_family;
  val_value_t *ip_rpf_check_val;
  boolean ip_rpf_check;

  name_val = val_find_child(
    msg->rpc_input,
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    y_ietf_i2rs_rib_N_name);
  if (name_val != NULL && name_val->res == NO_ERR) {
    name = VAL_STRING(name_val);
  }

  address_family_val = val_find_child(
    msg->rpc_input,
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    y_ietf_i2rs_rib_N_address_family);
  if (address_family_val != NULL && address_family_val->res == NO_ERR) {
    address_family = VAL_IDREF(address_family_val);
  }

  ip_rpf_check_val = val_find_child(
    msg->rpc_input,
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    y_ietf_i2rs_rib_N_ip_rpf_check);
  if (ip_rpf_check_val != NULL && ip_rpf_check_val->res == NO_ERR) {
    ip_rpf_check = VAL_BOOL(ip_rpf_check_val);
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if methnode is used */
  (void)methnode;

  /* invoke your device instrumentation code here */
  
  return res;

} /* y_ietf_i2rs_rib_rib_add_invoke */


/********************************************************************
* FUNCTION y_ietf_i2rs_rib_rib_delete_validate
* 
* RPC validation phase
* All YANG constraints have passed at this point.
* Add description-stmt checks in this function.
* 
* INPUTS:
*     see agt/agt_rpc.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t y_ietf_i2rs_rib_rib_delete_validate (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  xml_node_t *methnode)
{
  status_t res = NO_ERR;
  val_value_t *errorval = NULL;

  val_value_t *name_val;
  const xmlChar *name;

  name_val = val_find_child(
    msg->rpc_input,
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    y_ietf_i2rs_rib_N_name);
  if (name_val != NULL && name_val->res == NO_ERR) {
    name = VAL_STRING(name_val);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_OPERATION,
      res,
      methnode,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* y_ietf_i2rs_rib_rib_delete_validate */


/********************************************************************
* FUNCTION y_ietf_i2rs_rib_rib_delete_invoke
* 
* RPC invocation phase
* All constraints have passed at this point.
* Call device instrumentation code in this function.
* 
* INPUTS:
*     see agt/agt_rpc.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t y_ietf_i2rs_rib_rib_delete_invoke (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  xml_node_t *methnode)
{
  status_t res = NO_ERR;

  val_value_t *name_val;
  const xmlChar *name;

  name_val = val_find_child(
    msg->rpc_input,
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    y_ietf_i2rs_rib_N_name);
  if (name_val != NULL && name_val->res == NO_ERR) {
    name = VAL_STRING(name_val);
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if methnode is used */
  (void)methnode;

  /* invoke your device instrumentation code here */
  
  return res;

} /* y_ietf_i2rs_rib_rib_delete_invoke */


/********************************************************************
* FUNCTION y_ietf_i2rs_rib_route_add_validate
* 
* RPC validation phase
* All YANG constraints have passed at this point.
* Add description-stmt checks in this function.
* 
* INPUTS:
*     see agt/agt_rpc.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t y_ietf_i2rs_rib_route_add_validate (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  xml_node_t *methnode)
{
  status_t res = NO_ERR;
  val_value_t *errorval = NULL;

  val_value_t *return_failure_detail_val;
  boolean return_failure_detail;
  val_value_t *rib_name_val;
  const xmlChar *rib_name;
  val_value_t *routes_val;
  y_ietf_i2rs_rib_T_route_add_input_routes routes;

  return_failure_detail_val = val_find_child(
    msg->rpc_input,
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    y_ietf_i2rs_rib_N_return_failure_detail);
  if (return_failure_detail_val != NULL && return_failure_detail_val->res == NO_ERR) {
    return_failure_detail = VAL_BOOL(return_failure_detail_val);
  }

  rib_name_val = val_find_child(
    msg->rpc_input,
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    y_ietf_i2rs_rib_N_rib_name);
  if (rib_name_val != NULL && rib_name_val->res == NO_ERR) {
    rib_name = VAL_STRING(rib_name_val);
  }

  routes_val = val_find_child(
    msg->rpc_input,
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    y_ietf_i2rs_rib_N_routes);
  if (routes_val != NULL && routes_val->res == NO_ERR) {
    /* replace the following line with real code to fill in structure */
    (void)routes;
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_OPERATION,
      res,
      methnode,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* y_ietf_i2rs_rib_route_add_validate */





/*****************************************************************
******************************************************************/

static status_t find_route(val_value_t * routes_val){
	
        val_value_t* route_val;
        val_value_t* match_val;
        val_value_t* route_attributes_val;
        val_value_t* route_vendor_attributes_val;
        val_value_t* nexthop_val;

	for (route_val = val_find_child(routes_val, y_ietf_i2rs_rib_M_ietf_i2rs_rib, y_ietf_i2rs_rib_N_route_list);
		route_val != NULL;
		route_val = val_find_next_child(routes_val,
			y_ietf_i2rs_rib_M_ietf_i2rs_rib,
			y_ietf_i2rs_rib_N_route_list,
			route_val)) {
			match_val = val_find_child(route_val,
						      y_ietf_i2rs_rib_M_ietf_i2rs_rib,
						      y_ietf_i2rs_rib_N_match);

			if(match_val != NULL && match_val->res == NO_ERR){
			}

			route_attributes_val = val_find_child(route_val,
						      y_ietf_i2rs_rib_M_ietf_i2rs_rib,
						      y_ietf_i2rs_rib_N_route_attributes);
			route_vendor_attributes_val = val_find_child(route_val,
						      y_ietf_i2rs_rib_M_ietf_i2rs_rib,
						      y_ietf_i2rs_rib_N_route_vendor_attributes);
			nexthop_val = val_find_child(route_val,
						      y_ietf_i2rs_rib_M_ietf_i2rs_rib,
						      y_ietf_i2rs_rib_N_route_list);	
	}	
	return NO_ERR;
}

/****************************************************************
*****************************************************************/


/********************************************************************
* FUNCTION y_ietf_i2rs_rib_route_add_invoke
* 
* RPC invocation phase
* All constraints have passed at this point.
* Call device instrumentation code in this function.
* 
* INPUTS:
*     see agt/agt_rpc.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t y_ietf_i2rs_rib_route_add_invoke (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  xml_node_t *methnode)
{
  status_t res = NO_ERR;

  val_value_t *return_failure_detail_val;
  boolean return_failure_detail;
  val_value_t *rib_name_val;
  const xmlChar *rib_name;
  val_value_t *routes_val;
  y_ietf_i2rs_rib_T_route_add_input_routes routes;

  return_failure_detail_val = val_find_child(
    msg->rpc_input,
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    y_ietf_i2rs_rib_N_return_failure_detail);
  if (return_failure_detail_val != NULL && return_failure_detail_val->res == NO_ERR) {
    return_failure_detail = VAL_BOOL(return_failure_detail_val);
  }

  rib_name_val = val_find_child(
    msg->rpc_input,
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    y_ietf_i2rs_rib_N_rib_name);
  if (rib_name_val != NULL && rib_name_val->res == NO_ERR) {
    rib_name = VAL_STRING(rib_name_val);
  }

  routes_val = val_find_child(
    msg->rpc_input,
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    y_ietf_i2rs_rib_N_routes);
  if (routes_val != NULL && routes_val->res == NO_ERR) {
    /* replace the following line with real code to fill in structure */
    (void)routes;
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if methnode is used */
  (void)methnode;

  /* invoke your device instrumentation code here */
  
  return res;

} /* y_ietf_i2rs_rib_route_add_invoke */


/********************************************************************
* FUNCTION y_ietf_i2rs_rib_route_delete_validate
* 
* RPC validation phase
* All YANG constraints have passed at this point.
* Add description-stmt checks in this function.
* 
* INPUTS:
*     see agt/agt_rpc.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t y_ietf_i2rs_rib_route_delete_validate (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  xml_node_t *methnode)
{
  status_t res = NO_ERR;
  val_value_t *errorval = NULL;

  val_value_t *return_failure_detail_val;
  boolean return_failure_detail;
  val_value_t *rib_name_val;
  const xmlChar *rib_name;
  val_value_t *routes_val;
  y_ietf_i2rs_rib_T_route_delete_input_routes routes;

  return_failure_detail_val = val_find_child(
    msg->rpc_input,
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    y_ietf_i2rs_rib_N_return_failure_detail);
  if (return_failure_detail_val != NULL && return_failure_detail_val->res == NO_ERR) {
    return_failure_detail = VAL_BOOL(return_failure_detail_val);
  }

  rib_name_val = val_find_child(
    msg->rpc_input,
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    y_ietf_i2rs_rib_N_rib_name);
  if (rib_name_val != NULL && rib_name_val->res == NO_ERR) {
    rib_name = VAL_STRING(rib_name_val);
  }

  routes_val = val_find_child(
    msg->rpc_input,
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    y_ietf_i2rs_rib_N_routes);
  if (routes_val != NULL && routes_val->res == NO_ERR) {
    /* replace the following line with real code to fill in structure */
    (void)routes;
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_OPERATION,
      res,
      methnode,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* y_ietf_i2rs_rib_route_delete_validate */


/********************************************************************
* FUNCTION y_ietf_i2rs_rib_route_delete_invoke
* 
* RPC invocation phase
* All constraints have passed at this point.
* Call device instrumentation code in this function.
* 
* INPUTS:
*     see agt/agt_rpc.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t y_ietf_i2rs_rib_route_delete_invoke (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  xml_node_t *methnode)
{
  status_t res = NO_ERR;

  val_value_t *return_failure_detail_val;
  boolean return_failure_detail;
  val_value_t *rib_name_val;
  const xmlChar *rib_name;
  val_value_t *routes_val;
  y_ietf_i2rs_rib_T_route_delete_input_routes routes;

  return_failure_detail_val = val_find_child(
    msg->rpc_input,
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    y_ietf_i2rs_rib_N_return_failure_detail);
  if (return_failure_detail_val != NULL && return_failure_detail_val->res == NO_ERR) {
    return_failure_detail = VAL_BOOL(return_failure_detail_val);
  }

  rib_name_val = val_find_child(
    msg->rpc_input,
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    y_ietf_i2rs_rib_N_rib_name);
  if (rib_name_val != NULL && rib_name_val->res == NO_ERR) {
    rib_name = VAL_STRING(rib_name_val);
  }

  routes_val = val_find_child(
    msg->rpc_input,
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    y_ietf_i2rs_rib_N_routes);
  if (routes_val != NULL && routes_val->res == NO_ERR) {
    /* replace the following line with real code to fill in structure */
    (void)routes;
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if methnode is used */
  (void)methnode;

  /* invoke your device instrumentation code here */
  
  return res;

} /* y_ietf_i2rs_rib_route_delete_invoke */


/********************************************************************
* FUNCTION y_ietf_i2rs_rib_route_update_validate
* 
* RPC validation phase
* All YANG constraints have passed at this point.
* Add description-stmt checks in this function.
* 
* INPUTS:
*     see agt/agt_rpc.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t y_ietf_i2rs_rib_route_update_validate (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  xml_node_t *methnode)
{
  status_t res = NO_ERR;
  val_value_t *errorval = NULL;

  val_value_t *return_failure_detail_val;
  boolean return_failure_detail;
  val_value_t *rib_name_val;
  const xmlChar *rib_name;
  val_value_t *match_options_val;
  y_ietf_i2rs_rib_T_route_update_input_match_options match_options;

  return_failure_detail_val = val_find_child(
    msg->rpc_input,
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    y_ietf_i2rs_rib_N_return_failure_detail);
  if (return_failure_detail_val != NULL && return_failure_detail_val->res == NO_ERR) {
    return_failure_detail = VAL_BOOL(return_failure_detail_val);
  }

  rib_name_val = val_find_child(
    msg->rpc_input,
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    y_ietf_i2rs_rib_N_rib_name);
  if (rib_name_val != NULL && rib_name_val->res == NO_ERR) {
    rib_name = VAL_STRING(rib_name_val);
  }

  match_options_val = val_find_child(
    msg->rpc_input,
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    y_ietf_i2rs_rib_N_match_options);
  if (match_options_val != NULL && match_options_val->res == NO_ERR) {
    /* replace the following line with real code to fill in structure */
    (void)match_options;
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_OPERATION,
      res,
      methnode,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* y_ietf_i2rs_rib_route_update_validate */


/********************************************************************
* FUNCTION y_ietf_i2rs_rib_route_update_invoke
* 
* RPC invocation phase
* All constraints have passed at this point.
* Call device instrumentation code in this function.
* 
* INPUTS:
*     see agt/agt_rpc.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t y_ietf_i2rs_rib_route_update_invoke (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  xml_node_t *methnode)
{
  status_t res = NO_ERR;

  val_value_t *return_failure_detail_val;
  boolean return_failure_detail;
  val_value_t *rib_name_val;
  const xmlChar *rib_name;
  val_value_t *match_options_val;
  y_ietf_i2rs_rib_T_route_update_input_match_options match_options;

  return_failure_detail_val = val_find_child(
    msg->rpc_input,
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    y_ietf_i2rs_rib_N_return_failure_detail);
  if (return_failure_detail_val != NULL && return_failure_detail_val->res == NO_ERR) {
    return_failure_detail = VAL_BOOL(return_failure_detail_val);
  }

  rib_name_val = val_find_child(
    msg->rpc_input,
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    y_ietf_i2rs_rib_N_rib_name);
  if (rib_name_val != NULL && rib_name_val->res == NO_ERR) {
    rib_name = VAL_STRING(rib_name_val);
  }

  match_options_val = val_find_child(
    msg->rpc_input,
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    y_ietf_i2rs_rib_N_match_options);
  if (match_options_val != NULL && match_options_val->res == NO_ERR) {
    /* replace the following line with real code to fill in structure */
    (void)match_options;
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if methnode is used */
  (void)methnode;

  /* invoke your device instrumentation code here */
  
  return res;

} /* y_ietf_i2rs_rib_route_update_invoke */


/********************************************************************
* FUNCTION y_ietf_i2rs_rib_nh_add_validate
* 
* RPC validation phase
* All YANG constraints have passed at this point.
* Add description-stmt checks in this function.
* 
* INPUTS:
*     see agt/agt_rpc.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t y_ietf_i2rs_rib_nh_add_validate (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  xml_node_t *methnode)
{
  status_t res = NO_ERR;
  val_value_t *errorval = NULL;

  val_value_t *rib_name_val;
  const xmlChar *rib_name;
  val_value_t *nexthop_id_val;
  uint32 nexthop_id;
  val_value_t *sharing_flag_val;
  boolean sharing_flag;
  val_value_t *nexthop_type_val;
  y_ietf_i2rs_rib_T_nh_add_input_nexthop_type nexthop_type;

  rib_name_val = val_find_child(
    msg->rpc_input,
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    y_ietf_i2rs_rib_N_rib_name);
  if (rib_name_val != NULL && rib_name_val->res == NO_ERR) {
    rib_name = VAL_STRING(rib_name_val);
  }

  nexthop_id_val = val_find_child(
    msg->rpc_input,
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    y_ietf_i2rs_rib_N_nexthop_id);
  if (nexthop_id_val != NULL && nexthop_id_val->res == NO_ERR) {
    nexthop_id = VAL_UINT(nexthop_id_val);
  }

  sharing_flag_val = val_find_child(
    msg->rpc_input,
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    y_ietf_i2rs_rib_N_sharing_flag);
  if (sharing_flag_val != NULL && sharing_flag_val->res == NO_ERR) {
    sharing_flag = VAL_BOOL(sharing_flag_val);
  }

  nexthop_type_val = val_find_child(
    msg->rpc_input,
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    y_ietf_i2rs_rib_N_nexthop_type);
  if (nexthop_type_val != NULL && nexthop_type_val->res == NO_ERR) {
    /* replace the following line with real code to fill in structure */
    (void)nexthop_type;
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_OPERATION,
      res,
      methnode,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* y_ietf_i2rs_rib_nh_add_validate */


/********************************************************************
* FUNCTION y_ietf_i2rs_rib_nh_add_invoke
* 
* RPC invocation phase
* All constraints have passed at this point.
* Call device instrumentation code in this function.
* 
* INPUTS:
*     see agt/agt_rpc.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t y_ietf_i2rs_rib_nh_add_invoke (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  xml_node_t *methnode)
{
  status_t res = NO_ERR;

  val_value_t *rib_name_val;
  const xmlChar *rib_name;
  val_value_t *nexthop_id_val;
  uint32 nexthop_id;
  val_value_t *sharing_flag_val;
  boolean sharing_flag;
  val_value_t *nexthop_type_val;
  y_ietf_i2rs_rib_T_nh_add_input_nexthop_type nexthop_type;

  rib_name_val = val_find_child(
    msg->rpc_input,
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    y_ietf_i2rs_rib_N_rib_name);
  if (rib_name_val != NULL && rib_name_val->res == NO_ERR) {
    rib_name = VAL_STRING(rib_name_val);
  }

  nexthop_id_val = val_find_child(
    msg->rpc_input,
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    y_ietf_i2rs_rib_N_nexthop_id);
  if (nexthop_id_val != NULL && nexthop_id_val->res == NO_ERR) {
    nexthop_id = VAL_UINT(nexthop_id_val);
  }

  sharing_flag_val = val_find_child(
    msg->rpc_input,
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    y_ietf_i2rs_rib_N_sharing_flag);
  if (sharing_flag_val != NULL && sharing_flag_val->res == NO_ERR) {
    sharing_flag = VAL_BOOL(sharing_flag_val);
  }

  nexthop_type_val = val_find_child(
    msg->rpc_input,
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    y_ietf_i2rs_rib_N_nexthop_type);
  if (nexthop_type_val != NULL && nexthop_type_val->res == NO_ERR) {
    /* replace the following line with real code to fill in structure */
    (void)nexthop_type;
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if methnode is used */
  (void)methnode;

  /* invoke your device instrumentation code here */
  
  return res;

} /* y_ietf_i2rs_rib_nh_add_invoke */


/********************************************************************
* FUNCTION y_ietf_i2rs_rib_nh_delete_validate
* 
* RPC validation phase
* All YANG constraints have passed at this point.
* Add description-stmt checks in this function.
* 
* INPUTS:
*     see agt/agt_rpc.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t y_ietf_i2rs_rib_nh_delete_validate (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  xml_node_t *methnode)
{
  status_t res = NO_ERR;
  val_value_t *errorval = NULL;

  val_value_t *rib_name_val;
  const xmlChar *rib_name;
  val_value_t *nexthop_id_val;
  uint32 nexthop_id;
  val_value_t *sharing_flag_val;
  boolean sharing_flag;
  val_value_t *nexthop_type_val;
  y_ietf_i2rs_rib_T_nh_delete_input_nexthop_type nexthop_type;

  rib_name_val = val_find_child(
    msg->rpc_input,
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    y_ietf_i2rs_rib_N_rib_name);
  if (rib_name_val != NULL && rib_name_val->res == NO_ERR) {
    rib_name = VAL_STRING(rib_name_val);
  }

  nexthop_id_val = val_find_child(
    msg->rpc_input,
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    y_ietf_i2rs_rib_N_nexthop_id);
  if (nexthop_id_val != NULL && nexthop_id_val->res == NO_ERR) {
    nexthop_id = VAL_UINT(nexthop_id_val);
  }

  sharing_flag_val = val_find_child(
    msg->rpc_input,
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    y_ietf_i2rs_rib_N_sharing_flag);
  if (sharing_flag_val != NULL && sharing_flag_val->res == NO_ERR) {
    sharing_flag = VAL_BOOL(sharing_flag_val);
  }

  nexthop_type_val = val_find_child(
    msg->rpc_input,
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    y_ietf_i2rs_rib_N_nexthop_type);
  if (nexthop_type_val != NULL && nexthop_type_val->res == NO_ERR) {
    /* replace the following line with real code to fill in structure */
    (void)nexthop_type;
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_OPERATION,
      res,
      methnode,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* y_ietf_i2rs_rib_nh_delete_validate */


/********************************************************************
* FUNCTION y_ietf_i2rs_rib_nh_delete_invoke
* 
* RPC invocation phase
* All constraints have passed at this point.
* Call device instrumentation code in this function.
* 
* INPUTS:
*     see agt/agt_rpc.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t y_ietf_i2rs_rib_nh_delete_invoke (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  xml_node_t *methnode)
{
  status_t res = NO_ERR;

  val_value_t *rib_name_val;
  const xmlChar *rib_name;
  val_value_t *nexthop_id_val;
  uint32 nexthop_id;
  val_value_t *sharing_flag_val;
  boolean sharing_flag;
  val_value_t *nexthop_type_val;
  y_ietf_i2rs_rib_T_nh_delete_input_nexthop_type nexthop_type;

  rib_name_val = val_find_child(
    msg->rpc_input,
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    y_ietf_i2rs_rib_N_rib_name);
  if (rib_name_val != NULL && rib_name_val->res == NO_ERR) {
    rib_name = VAL_STRING(rib_name_val);
  }

  nexthop_id_val = val_find_child(
    msg->rpc_input,
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    y_ietf_i2rs_rib_N_nexthop_id);
  if (nexthop_id_val != NULL && nexthop_id_val->res == NO_ERR) {
    nexthop_id = VAL_UINT(nexthop_id_val);
  }

  sharing_flag_val = val_find_child(
    msg->rpc_input,
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    y_ietf_i2rs_rib_N_sharing_flag);
  if (sharing_flag_val != NULL && sharing_flag_val->res == NO_ERR) {
    sharing_flag = VAL_BOOL(sharing_flag_val);
  }

  nexthop_type_val = val_find_child(
    msg->rpc_input,
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    y_ietf_i2rs_rib_N_nexthop_type);
  if (nexthop_type_val != NULL && nexthop_type_val->res == NO_ERR) {
    /* replace the following line with real code to fill in structure */
    (void)nexthop_type;
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if methnode is used */
  (void)methnode;

  /* invoke your device instrumentation code here */
  
  return res;

} /* y_ietf_i2rs_rib_nh_delete_invoke */


/********************************************************************
* FUNCTION y_ietf_i2rs_rib_nexthop_resolution_status_change_send
* 
* Send a y_ietf_i2rs_rib_nexthop_resolution_status_change notification
* Called by your code when notification event occurs
* 
********************************************************************/
void y_ietf_i2rs_rib_nexthop_resolution_status_change_send (
  y_ietf_i2rs_rib_T_nexthop_resolution_status_change_nexthop *nexthop,
  const val_idref_t *nexthop_state)
{
  agt_not_msg_t *notif;
  val_value_t *parmval;
  status_t res = NO_ERR;


  if (LOGDEBUG) {
    log_debug("\nGenerating <nexthop-resolution-status-change> notification");
  }
  
  notif = agt_not_new_notification(nexthop_resolution_status_change_obj);
  if (notif == NULL) {
    log_error("\nError: malloc failed, cannot send "
    "<nexthop-resolution-status-change> notification");
    return;
  }
  
  /* add container nexthop to payload
   * replace following line with real code
   */
  (void)nexthop;

  /* add nexthop_state to payload */
  parmval = agt_make_idref_leaf(
    nexthop_resolution_status_change_obj,
    y_ietf_i2rs_rib_N_nexthop_state,
    nexthop_state,
    &res);
  if (parmval == NULL) {
    log_error(
      "\nError: make leaf failed (%s), cannot send "
      "<nexthop-resolution-status-change> notification",
      get_error_string(res));
  } else {
    agt_not_add_to_payload(notif, parmval);
  }
  
  agt_not_queue_notification(notif);
  
} /* y_ietf_i2rs_rib_nexthop_resolution_status_change_send */


/********************************************************************
* FUNCTION y_ietf_i2rs_rib_route_change_send
* 
* Send a y_ietf_i2rs_rib_route_change notification
* Called by your code when notification event occurs
* 
********************************************************************/
void y_ietf_i2rs_rib_route_change_send (
  const xmlChar *rib_name,
  const val_idref_t *address_family,
  uint64 route_index,
  y_ietf_i2rs_rib_T_route_change_match *match,
  const val_idref_t *route_installed_state,
  const val_idref_t *route_state,
  dlq_hdr_t *route_change_reasons)
{
  agt_not_msg_t *notif;
  val_value_t *parmval;
  status_t res = NO_ERR;


  if (LOGDEBUG) {
    log_debug("\nGenerating <route-change> notification");
  }
  
  notif = agt_not_new_notification(route_change_obj);
  if (notif == NULL) {
    log_error("\nError: malloc failed, cannot send "
    "<route-change> notification");
    return;
  }
  
  /* add rib_name to payload */
  parmval = agt_make_leaf(
    route_change_obj,
    y_ietf_i2rs_rib_N_rib_name,
    rib_name,
    &res);
  if (parmval == NULL) {
    log_error(
      "\nError: make leaf failed (%s), cannot send "
      "<route-change> notification",
      get_error_string(res));
  } else {
    agt_not_add_to_payload(notif, parmval);
  }
  
  /* add address_family to payload */
  parmval = agt_make_idref_leaf(
    route_change_obj,
    y_ietf_i2rs_rib_N_address_family,
    address_family,
    &res);
  if (parmval == NULL) {
    log_error(
      "\nError: make leaf failed (%s), cannot send "
      "<route-change> notification",
      get_error_string(res));
  } else {
    agt_not_add_to_payload(notif, parmval);
  }
  
  /* add route_index to payload */
  parmval = agt_make_uint64_leaf(
    route_change_obj,
    y_ietf_i2rs_rib_N_route_index,
    route_index,
    &res);
  if (parmval == NULL) {
    log_error(
      "\nError: make leaf failed (%s), cannot send "
      "<route-change> notification",
      get_error_string(res));
  } else {
    agt_not_add_to_payload(notif, parmval);
  }
  
  /* add container match to payload
   * replace following line with real code
   */
  (void)match;

  /* add route_installed_state to payload */
  parmval = agt_make_idref_leaf(
    route_change_obj,
    y_ietf_i2rs_rib_N_route_installed_state,
    route_installed_state,
    &res);
  if (parmval == NULL) {
    log_error(
      "\nError: make leaf failed (%s), cannot send "
      "<route-change> notification",
      get_error_string(res));
  } else {
    agt_not_add_to_payload(notif, parmval);
  }
  
  /* add route_state to payload */
  parmval = agt_make_idref_leaf(
    route_change_obj,
    y_ietf_i2rs_rib_N_route_state,
    route_state,
    &res);
  if (parmval == NULL) {
    log_error(
      "\nError: make leaf failed (%s), cannot send "
      "<route-change> notification",
      get_error_string(res));
  } else {
    agt_not_add_to_payload(notif, parmval);
  }
  
  /* add list route_change_reasons to payload
   * replace following line with real code
   */
  (void)route_change_reasons;

  agt_not_queue_notification(notif);
  
} /* y_ietf_i2rs_rib_route_change_send */

/********************************************************************
* FUNCTION y_ietf_i2rs_rib_init
* 
* initialize the ietf-i2rs-rib server instrumentation library
* 
* INPUTS:
*    modname == requested module name
*    revision == requested version (NULL for any)
* 
* RETURNS:
*     error status
********************************************************************/
status_t y_ietf_i2rs_rib_init (
  const xmlChar *modname,
  const xmlChar *revision)
{
  status_t res = NO_ERR;
  agt_profile_t *agt_profile = agt_get_profile();

  y_ietf_i2rs_rib_init_static_vars();

  /* change if custom handling done */
  if (xml_strcmp(modname, y_ietf_i2rs_rib_M_ietf_i2rs_rib)) {
    return ERR_NCX_UNKNOWN_MODULE;
  }

  if (revision && xml_strcmp(revision, y_ietf_i2rs_rib_R_ietf_i2rs_rib)) {
    return ERR_NCX_WRONG_VERSION;
  }

#ifdef u_ietf_i2rs_rib_F_nexthop_tunnel
  ncx_set_feature_enable(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"nexthop-tunnel",
    TRUE);
#else
  ncx_set_feature_enable(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"nexthop-tunnel",
    FALSE);
#endif

#ifdef u_ietf_i2rs_rib_F_nexthop_chain
  ncx_set_feature_enable(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"nexthop-chain",
    TRUE);
#else
  ncx_set_feature_enable(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"nexthop-chain",
    FALSE);
#endif

#ifdef u_ietf_i2rs_rib_F_nexthop_protection
  ncx_set_feature_enable(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"nexthop-protection",
    TRUE);
#else
  ncx_set_feature_enable(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"nexthop-protection",
    FALSE);
#endif

#ifdef u_ietf_i2rs_rib_F_nexthop_replicates
  ncx_set_feature_enable(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"nexthop-replicates",
    TRUE);
#else
  ncx_set_feature_enable(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"nexthop-replicates",
    FALSE);
#endif

#ifdef u_ietf_i2rs_rib_F_nexthop_load_balance
  ncx_set_feature_enable(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"nexthop-load-balance",
    TRUE);
#else
  ncx_set_feature_enable(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"nexthop-load-balance",
    FALSE);
#endif

#ifdef u_ietf_i2rs_rib_F_ipv4_tunnel
  ncx_set_feature_enable(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"ipv4-tunnel",
    TRUE);
#else
  ncx_set_feature_enable(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"ipv4-tunnel",
    FALSE);
#endif

#ifdef u_ietf_i2rs_rib_F_ipv6_tunnel
  ncx_set_feature_enable(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"ipv6-tunnel",
    TRUE);
#else
  ncx_set_feature_enable(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"ipv6-tunnel",
    FALSE);
#endif

#ifdef u_ietf_i2rs_rib_F_mpls_tunnel
  ncx_set_feature_enable(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"mpls-tunnel",
    TRUE);
#else
  ncx_set_feature_enable(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"mpls-tunnel",
    FALSE);
#endif

#ifdef u_ietf_i2rs_rib_F_vxlan_tunnel
  ncx_set_feature_enable(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"vxlan-tunnel",
    TRUE);
#else
  ncx_set_feature_enable(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"vxlan-tunnel",
    FALSE);
#endif

#ifdef u_ietf_i2rs_rib_F_gre_tunnel
  ncx_set_feature_enable(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"gre-tunnel",
    TRUE);
#else
  ncx_set_feature_enable(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"gre-tunnel",
    FALSE);
#endif

#ifdef u_ietf_i2rs_rib_F_nvgre_tunnel
  ncx_set_feature_enable(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"nvgre-tunnel",
    TRUE);
#else
  ncx_set_feature_enable(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"nvgre-tunnel",
    FALSE);
#endif

#ifdef u_ietf_i2rs_rib_F_route_vendor_attributes
  ncx_set_feature_enable(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"route-vendor-attributes",
    TRUE);
#else
  ncx_set_feature_enable(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"route-vendor-attributes",
    FALSE);
#endif

  res = ncxmod_load_module(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    &agt_profile->agt_savedevQ,
    &ietf_i2rs_rib_mod);
  if (res != NO_ERR) {
    return res;
  }

  routing_instance_obj = ncx_find_object(
    ietf_i2rs_rib_mod,
    y_ietf_i2rs_rib_N_routing_instance);
  if (ietf_i2rs_rib_mod == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  rib_add_obj = ncx_find_object(
    ietf_i2rs_rib_mod,
    y_ietf_i2rs_rib_N_rib_add);
  if (ietf_i2rs_rib_mod == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  rib_delete_obj = ncx_find_object(
    ietf_i2rs_rib_mod,
    y_ietf_i2rs_rib_N_rib_delete);
  if (ietf_i2rs_rib_mod == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  route_add_obj = ncx_find_object(
    ietf_i2rs_rib_mod,
    y_ietf_i2rs_rib_N_route_add);
  if (ietf_i2rs_rib_mod == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  route_delete_obj = ncx_find_object(
    ietf_i2rs_rib_mod,
    y_ietf_i2rs_rib_N_route_delete);
  if (ietf_i2rs_rib_mod == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  route_update_obj = ncx_find_object(
    ietf_i2rs_rib_mod,
    y_ietf_i2rs_rib_N_route_update);
  if (ietf_i2rs_rib_mod == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  nh_add_obj = ncx_find_object(
    ietf_i2rs_rib_mod,
    y_ietf_i2rs_rib_N_nh_add);
  if (ietf_i2rs_rib_mod == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  nh_delete_obj = ncx_find_object(
    ietf_i2rs_rib_mod,
    y_ietf_i2rs_rib_N_nh_delete);
  if (ietf_i2rs_rib_mod == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  nexthop_resolution_status_change_obj = ncx_find_object(
    ietf_i2rs_rib_mod,
    y_ietf_i2rs_rib_N_nexthop_resolution_status_change);
  if (ietf_i2rs_rib_mod == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  route_change_obj = ncx_find_object(
    ietf_i2rs_rib_mod,
    y_ietf_i2rs_rib_N_route_change);
  if (ietf_i2rs_rib_mod == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  res = agt_rpc_register_method(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    y_ietf_i2rs_rib_N_rib_add,
    AGT_RPC_PH_VALIDATE,
    y_ietf_i2rs_rib_rib_add_validate);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    y_ietf_i2rs_rib_N_rib_add,
    AGT_RPC_PH_INVOKE,
    y_ietf_i2rs_rib_rib_add_invoke);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    y_ietf_i2rs_rib_N_rib_delete,
    AGT_RPC_PH_VALIDATE,
    y_ietf_i2rs_rib_rib_delete_validate);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    y_ietf_i2rs_rib_N_rib_delete,
    AGT_RPC_PH_INVOKE,
    y_ietf_i2rs_rib_rib_delete_invoke);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    y_ietf_i2rs_rib_N_route_add,
    AGT_RPC_PH_VALIDATE,
    y_ietf_i2rs_rib_route_add_validate);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    y_ietf_i2rs_rib_N_route_add,
    AGT_RPC_PH_INVOKE,
    y_ietf_i2rs_rib_route_add_invoke);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    y_ietf_i2rs_rib_N_route_delete,
    AGT_RPC_PH_VALIDATE,
    y_ietf_i2rs_rib_route_delete_validate);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    y_ietf_i2rs_rib_N_route_delete,
    AGT_RPC_PH_INVOKE,
    y_ietf_i2rs_rib_route_delete_invoke);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    y_ietf_i2rs_rib_N_route_update,
    AGT_RPC_PH_VALIDATE,
    y_ietf_i2rs_rib_route_update_validate);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    y_ietf_i2rs_rib_N_route_update,
    AGT_RPC_PH_INVOKE,
    y_ietf_i2rs_rib_route_update_invoke);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    y_ietf_i2rs_rib_N_nh_add,
    AGT_RPC_PH_VALIDATE,
    y_ietf_i2rs_rib_nh_add_validate);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    y_ietf_i2rs_rib_N_nh_add,
    AGT_RPC_PH_INVOKE,
    y_ietf_i2rs_rib_nh_add_invoke);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    y_ietf_i2rs_rib_N_nh_delete,
    AGT_RPC_PH_VALIDATE,
    y_ietf_i2rs_rib_nh_delete_validate);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    y_ietf_i2rs_rib_N_nh_delete,
    AGT_RPC_PH_INVOKE,
    y_ietf_i2rs_rib_nh_delete_invoke);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/name",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_name_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/interface-list",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_interface_list_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/interface-list/name",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_interface_list_name_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/router-id",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_router_id_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/lookup-limit",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_lookup_limit_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/name",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_name_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/address-family",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_address_family_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/ip-rpf-check",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_ip_rpf_check_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/route-index",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_route_index_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/match",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_match_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/match/route-type/ipv4/ipv4",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_match_route_type_ipv4_ipv4_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/match/route-type/ipv4/ipv4/ip-route-match-type/dest-ipv4-address/dest-ipv4-prefix",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_match_route_type_ipv4_ipv4_ip_route_match_type_dest_ipv4_address_dest_ipv4_prefix_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/match/route-type/ipv4/ipv4/ip-route-match-type/src-ipv4-address/src-ipv4-prefix",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_match_route_type_ipv4_ipv4_ip_route_match_type_src_ipv4_address_src_ipv4_prefix_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/match/route-type/ipv4/ipv4/ip-route-match-type/dest-src-ipv4-address/dest-src-ipv4-address",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_match_route_type_ipv4_ipv4_ip_route_match_type_dest_src_ipv4_address_dest_src_ipv4_address_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/match/route-type/ipv4/ipv4/ip-route-match-type/dest-src-ipv4-address/dest-src-ipv4-address/dest-ipv4-prefix",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_match_route_type_ipv4_ipv4_ip_route_match_type_dest_src_ipv4_address_dest_src_ipv4_address_dest_ipv4_prefix_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/match/route-type/ipv4/ipv4/ip-route-match-type/dest-src-ipv4-address/dest-src-ipv4-address/src-ipv4-prefix",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_match_route_type_ipv4_ipv4_ip_route_match_type_dest_src_ipv4_address_dest_src_ipv4_address_src_ipv4_prefix_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/match/route-type/ipv6/ipv6",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_match_route_type_ipv6_ipv6_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/match/route-type/ipv6/ipv6/ip-route-match-type/dest-ipv6-address/dest-ipv6-prefix",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_match_route_type_ipv6_ipv6_ip_route_match_type_dest_ipv6_address_dest_ipv6_prefix_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/match/route-type/ipv6/ipv6/ip-route-match-type/src-ipv6-address/src-ipv6-prefix",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_match_route_type_ipv6_ipv6_ip_route_match_type_src_ipv6_address_src_ipv6_prefix_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/match/route-type/ipv6/ipv6/ip-route-match-type/dest-src-ipv6-address/dest-src-ipv6-address",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_match_route_type_ipv6_ipv6_ip_route_match_type_dest_src_ipv6_address_dest_src_ipv6_address_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/match/route-type/ipv6/ipv6/ip-route-match-type/dest-src-ipv6-address/dest-src-ipv6-address/dest-ipv6-prefix",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_match_route_type_ipv6_ipv6_ip_route_match_type_dest_src_ipv6_address_dest_src_ipv6_address_dest_ipv6_prefix_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/match/route-type/ipv6/ipv6/ip-route-match-type/dest-src-ipv6-address/dest-src-ipv6-address/src-ipv6-prefix",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_match_route_type_ipv6_ipv6_ip_route_match_type_dest_src_ipv6_address_dest_src_ipv6_address_src_ipv6_prefix_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/match/route-type/mpls-route/mpls-label",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_match_route_type_mpls_route_mpls_label_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/match/route-type/mac-route/mac-address",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_match_route_type_mac_route_mac_address_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/match/route-type/interface-route/interface-identifier",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_match_route_type_interface_route_interface_identifier_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-id",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_id_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/sharing-flag",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_sharing_flag_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/special-nexthop/special",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_special_nexthop_special_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/egress-interface-nexthop/outgoing-interface",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_egress_interface_nexthop_outgoing_interface_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/ipv4-address-nexthop/ipv4-address",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_ipv4_address_nexthop_ipv4_address_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/ipv6-address-nexthop/ipv6-address",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_ipv6_address_nexthop_ipv6_address_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/egress-interface-ipv4-nexthop/egress-interface-ipv4-address",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_egress_interface_ipv4_nexthop_egress_interface_ipv4_address_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/egress-interface-ipv4-nexthop/egress-interface-ipv4-address/outgoing-interface",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_egress_interface_ipv4_nexthop_egress_interface_ipv4_address_outgoing_interface_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/egress-interface-ipv4-nexthop/egress-interface-ipv4-address/ipv4-address",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_egress_interface_ipv4_nexthop_egress_interface_ipv4_address_ipv4_address_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/egress-interface-ipv6-nexthop/egress-interface-ipv6-address",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_egress_interface_ipv6_nexthop_egress_interface_ipv6_address_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/egress-interface-ipv6-nexthop/egress-interface-ipv6-address/outgoing-interface",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_egress_interface_ipv6_nexthop_egress_interface_ipv6_address_outgoing_interface_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/egress-interface-ipv6-nexthop/egress-interface-ipv6-address/ipv6-address",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_egress_interface_ipv6_nexthop_egress_interface_ipv6_address_ipv6_address_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/egress-interface-mac-nexthop/egress-interface-mac-address",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_egress_interface_mac_nexthop_egress_interface_mac_address_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/egress-interface-mac-nexthop/egress-interface-mac-address/outgoing-interface",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_egress_interface_mac_nexthop_egress_interface_mac_address_outgoing_interface_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/egress-interface-mac-nexthop/egress-interface-mac-address/ieee-mac-address",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_egress_interface_mac_nexthop_egress_interface_mac_address_ieee_mac_address_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/ipv4/ipv4-header",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_ipv4_ipv4_header_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/ipv4/ipv4-header/src-ipv4-address",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_ipv4_ipv4_header_src_ipv4_address_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/ipv4/ipv4-header/dest-ipv4-address",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_ipv4_ipv4_header_dest_ipv4_address_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/ipv4/ipv4-header/protocol",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_ipv4_ipv4_header_protocol_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/ipv4/ipv4-header/ttl",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_ipv4_ipv4_header_ttl_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/ipv4/ipv4-header/dscp",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_ipv4_ipv4_header_dscp_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/ipv6/ipv6-header",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_ipv6_ipv6_header_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/ipv6/ipv6-header/src-ipv6-address",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_ipv6_ipv6_header_src_ipv6_address_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/ipv6/ipv6-header/dest-ipv6-address",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_ipv6_ipv6_header_dest_ipv6_address_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/ipv6/ipv6-header/next-header",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_ipv6_ipv6_header_next_header_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/ipv6/ipv6-header/traffic-class",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_ipv6_ipv6_header_traffic_class_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/ipv6/ipv6-header/flow-label",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_ipv6_ipv6_header_flow_label_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/ipv6/ipv6-header/hop-limit",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_ipv6_ipv6_header_hop_limit_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/mpls/mpls-header",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_mpls_mpls_header_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/mpls/mpls-header/label-operations",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_mpls_mpls_header_label_operations_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/mpls/mpls-header/label-operations/label-oper-id",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_mpls_mpls_header_label_operations_label_oper_id_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/mpls/mpls-header/label-operations/label-actions/label-push/label-push",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_mpls_mpls_header_label_operations_label_actions_label_push_label_push_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/mpls/mpls-header/label-operations/label-actions/label-push/label-push/label",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_mpls_mpls_header_label_operations_label_actions_label_push_label_push_label_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/mpls/mpls-header/label-operations/label-actions/label-push/label-push/s-bit",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_mpls_mpls_header_label_operations_label_actions_label_push_label_push_s_bit_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/mpls/mpls-header/label-operations/label-actions/label-push/label-push/tc-value",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_mpls_mpls_header_label_operations_label_actions_label_push_label_push_tc_value_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/mpls/mpls-header/label-operations/label-actions/label-push/label-push/ttl-value",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_mpls_mpls_header_label_operations_label_actions_label_push_label_push_ttl_value_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/mpls/mpls-header/label-operations/label-actions/label-swap/label-swap",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_mpls_mpls_header_label_operations_label_actions_label_swap_label_swap_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/mpls/mpls-header/label-operations/label-actions/label-swap/label-swap/in-label",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_mpls_mpls_header_label_operations_label_actions_label_swap_label_swap_in_label_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/mpls/mpls-header/label-operations/label-actions/label-swap/label-swap/out-label",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_mpls_mpls_header_label_operations_label_actions_label_swap_label_swap_out_label_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/mpls/mpls-header/label-operations/label-actions/label-swap/label-swap/ttl-action",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_mpls_mpls_header_label_operations_label_actions_label_swap_label_swap_ttl_action_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/gre/gre-header",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_gre_gre_header_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/gre/gre-header/dest-address-type/ipv4/ipv4-dest",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_gre_gre_header_dest_address_type_ipv4_ipv4_dest_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/gre/gre-header/dest-address-type/ipv6/ipv6-dest",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_gre_gre_header_dest_address_type_ipv6_ipv6_dest_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/gre/gre-header/protocol-type",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_gre_gre_header_protocol_type_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/gre/gre-header/key",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_gre_gre_header_key_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/nvgre/nvgre-header",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_nvgre_nvgre_header_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/nvgre/nvgre-header/nvgre-type/ipv4/src-ipv4-address",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_nvgre_nvgre_header_nvgre_type_ipv4_src_ipv4_address_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/nvgre/nvgre-header/nvgre-type/ipv4/dest-ipv4-address",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_nvgre_nvgre_header_nvgre_type_ipv4_dest_ipv4_address_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/nvgre/nvgre-header/nvgre-type/ipv4/protocol",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_nvgre_nvgre_header_nvgre_type_ipv4_protocol_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/nvgre/nvgre-header/nvgre-type/ipv4/ttl",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_nvgre_nvgre_header_nvgre_type_ipv4_ttl_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/nvgre/nvgre-header/nvgre-type/ipv4/dscp",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_nvgre_nvgre_header_nvgre_type_ipv4_dscp_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/nvgre/nvgre-header/nvgre-type/ipv6/src-ipv6-address",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_nvgre_nvgre_header_nvgre_type_ipv6_src_ipv6_address_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/nvgre/nvgre-header/nvgre-type/ipv6/dest-ipv6-address",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_nvgre_nvgre_header_nvgre_type_ipv6_dest_ipv6_address_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/nvgre/nvgre-header/nvgre-type/ipv6/next-header",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_nvgre_nvgre_header_nvgre_type_ipv6_next_header_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/nvgre/nvgre-header/nvgre-type/ipv6/traffic-class",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_nvgre_nvgre_header_nvgre_type_ipv6_traffic_class_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/nvgre/nvgre-header/nvgre-type/ipv6/flow-label",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_nvgre_nvgre_header_nvgre_type_ipv6_flow_label_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/nvgre/nvgre-header/nvgre-type/ipv6/hop-limit",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_nvgre_nvgre_header_nvgre_type_ipv6_hop_limit_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/nvgre/nvgre-header/virtual-subnet-id",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_nvgre_nvgre_header_virtual_subnet_id_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/nvgre/nvgre-header/flow-id",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_nvgre_nvgre_header_flow_id_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/vxlan/vxlan-header",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_vxlan_vxlan_header_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/vxlan/vxlan-header/vxlan-type/ipv4/src-ipv4-address",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_vxlan_vxlan_header_vxlan_type_ipv4_src_ipv4_address_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/vxlan/vxlan-header/vxlan-type/ipv4/dest-ipv4-address",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_vxlan_vxlan_header_vxlan_type_ipv4_dest_ipv4_address_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/vxlan/vxlan-header/vxlan-type/ipv4/protocol",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_vxlan_vxlan_header_vxlan_type_ipv4_protocol_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/vxlan/vxlan-header/vxlan-type/ipv4/ttl",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_vxlan_vxlan_header_vxlan_type_ipv4_ttl_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/vxlan/vxlan-header/vxlan-type/ipv4/dscp",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_vxlan_vxlan_header_vxlan_type_ipv4_dscp_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/vxlan/vxlan-header/vxlan-type/ipv6/src-ipv6-address",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_vxlan_vxlan_header_vxlan_type_ipv6_src_ipv6_address_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/vxlan/vxlan-header/vxlan-type/ipv6/dest-ipv6-address",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_vxlan_vxlan_header_vxlan_type_ipv6_dest_ipv6_address_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/vxlan/vxlan-header/vxlan-type/ipv6/next-header",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_vxlan_vxlan_header_vxlan_type_ipv6_next_header_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/vxlan/vxlan-header/vxlan-type/ipv6/traffic-class",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_vxlan_vxlan_header_vxlan_type_ipv6_traffic_class_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/vxlan/vxlan-header/vxlan-type/ipv6/flow-label",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_vxlan_vxlan_header_vxlan_type_ipv6_flow_label_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/vxlan/vxlan-header/vxlan-type/ipv6/hop-limit",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_vxlan_vxlan_header_vxlan_type_ipv6_hop_limit_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/vxlan/vxlan-header/vxlan-identifier",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_encap_nexthop_tunnel_encap_tunnel_type_vxlan_vxlan_header_vxlan_identifier_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-decap-nexthop/tunnel-decap",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_decap_nexthop_tunnel_decap_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-decap-nexthop/tunnel-decap/tunnel-type/ipv4/ipv4-decap",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_decap_nexthop_tunnel_decap_tunnel_type_ipv4_ipv4_decap_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-decap-nexthop/tunnel-decap/tunnel-type/ipv4/ipv4-decap/ipv4-decap",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_decap_nexthop_tunnel_decap_tunnel_type_ipv4_ipv4_decap_ipv4_decap_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-decap-nexthop/tunnel-decap/tunnel-type/ipv4/ipv4-decap/ttl-action",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_decap_nexthop_tunnel_decap_tunnel_type_ipv4_ipv4_decap_ttl_action_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-decap-nexthop/tunnel-decap/tunnel-type/ipv6/ipv6-decap",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_decap_nexthop_tunnel_decap_tunnel_type_ipv6_ipv6_decap_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-decap-nexthop/tunnel-decap/tunnel-type/ipv6/ipv6-decap/ipv6-decap",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_decap_nexthop_tunnel_decap_tunnel_type_ipv6_ipv6_decap_ipv6_decap_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-decap-nexthop/tunnel-decap/tunnel-type/ipv6/ipv6-decap/hop-limit-action",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_decap_nexthop_tunnel_decap_tunnel_type_ipv6_ipv6_decap_hop_limit_action_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-decap-nexthop/tunnel-decap/tunnel-type/mpls/label-pop",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_decap_nexthop_tunnel_decap_tunnel_type_mpls_label_pop_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-decap-nexthop/tunnel-decap/tunnel-type/mpls/label-pop/label-pop",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_decap_nexthop_tunnel_decap_tunnel_type_mpls_label_pop_label_pop_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-decap-nexthop/tunnel-decap/tunnel-type/mpls/label-pop/ttl-action",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_tunnel_decap_nexthop_tunnel_decap_tunnel_type_mpls_label_pop_ttl_action_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/logical-tunnel-nexthop/logical-tunnel",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_logical_tunnel_nexthop_logical_tunnel_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/logical-tunnel-nexthop/logical-tunnel/tunnel-type",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_logical_tunnel_nexthop_logical_tunnel_tunnel_type_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/logical-tunnel-nexthop/logical-tunnel/tunnel-name",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_logical_tunnel_nexthop_logical_tunnel_tunnel_name_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/rib-name-nexthop/rib-name",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_rib_name_nexthop_rib_name_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/nexthop-identifier/nexthop-ref",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_base_nexthop_base_nexthop_base_type_nexthop_identifier_nexthop_ref_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-chain/nexthop-chain",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_chain_nexthop_chain_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-chain/nexthop-chain/nexthop-list",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_chain_nexthop_chain_nexthop_list_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-chain/nexthop-chain/nexthop-list/nexthop-member-id",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_chain_nexthop_chain_nexthop_list_nexthop_member_id_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-replicates/nexthop-replicates",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_replicates_nexthop_replicates_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-replicates/nexthop-replicates/nexthop-list",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_replicates_nexthop_replicates_nexthop_list_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-replicates/nexthop-replicates/nexthop-list/nexthop-member-id",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_replicates_nexthop_replicates_nexthop_list_nexthop_member_id_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-protection/nexthop-protection",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_protection_nexthop_protection_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-protection/nexthop-protection/nexthop-list",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_protection_nexthop_protection_nexthop_list_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-protection/nexthop-protection/nexthop-list/nexthop-member-id",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_protection_nexthop_protection_nexthop_list_nexthop_member_id_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-protection/nexthop-protection/nexthop-list/nexthop-preference",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_protection_nexthop_protection_nexthop_list_nexthop_preference_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-load-balance/nexthop-lb",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_load_balance_nexthop_lb_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-load-balance/nexthop-lb/nexthop-list",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_load_balance_nexthop_lb_nexthop_list_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-load-balance/nexthop-lb/nexthop-list/nexthop-member-id",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_load_balance_nexthop_lb_nexthop_list_nexthop_member_id_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-load-balance/nexthop-lb/nexthop-list/nexthop-lb-weight",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_nexthop_nexthop_type_nexthop_load_balance_nexthop_lb_nexthop_list_nexthop_lb_weight_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/route-status",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_route_status_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/route-attributes",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_route_attributes_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/route-attributes/route-preference",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_route_attributes_route_preference_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/route-attributes/local-only",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_route_attributes_local_only_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/route-attributes/address-family-route-attributes",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_route_attributes_address_family_route_attributes_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/route-vendor-attributes",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_route_list_route_vendor_attributes_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/nexthop-list",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_nexthop_list_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/nexthop-list/nexthop-member-id",
    y_ietf_i2rs_rib_R_ietf_i2rs_rib,
    ietf_i2rs_rib_routing_instance_rib_list_nexthop_list_nexthop_member_id_edit);
  if (res != NO_ERR) {
    return res;
  }

  /* put your module initialization code here */
  
  return res;
} /* y_ietf_i2rs_rib_init */

/********************************************************************
* FUNCTION y_ietf_i2rs_rib_init2
* 
* SIL init phase 2: non-config data structures
* Called after running config is loaded
* 
* RETURNS:
*     error status
********************************************************************/
status_t y_ietf_i2rs_rib_init2 (void)
{
  status_t res = NO_ERR;

  routing_instance_val = agt_init_cache(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    y_ietf_i2rs_rib_N_routing_instance,
    &res);
  if (res != NO_ERR) {
    return res;
  }

  /* put your init2 code here */

  return res;
} /* y_ietf_i2rs_rib_init2 */

/********************************************************************
* FUNCTION y_ietf_i2rs_rib_cleanup
*    cleanup the server instrumentation library
* 
********************************************************************/
void y_ietf_i2rs_rib_cleanup (void)
{
  
  agt_rpc_unregister_method(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    y_ietf_i2rs_rib_N_rib_add);
  
  agt_rpc_unregister_method(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    y_ietf_i2rs_rib_N_rib_delete);
  
  agt_rpc_unregister_method(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    y_ietf_i2rs_rib_N_route_add);
  
  agt_rpc_unregister_method(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    y_ietf_i2rs_rib_N_route_delete);
  
  agt_rpc_unregister_method(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    y_ietf_i2rs_rib_N_route_update);
  
  agt_rpc_unregister_method(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    y_ietf_i2rs_rib_N_nh_add);
  
  agt_rpc_unregister_method(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    y_ietf_i2rs_rib_N_nh_delete);
  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/name");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/interface-list");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/interface-list/name");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/router-id");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/lookup-limit");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/name");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/address-family");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/ip-rpf-check");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/route-index");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/match");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/match/route-type/ipv4/ipv4");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/match/route-type/ipv4/ipv4/ip-route-match-type/dest-ipv4-address/dest-ipv4-prefix");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/match/route-type/ipv4/ipv4/ip-route-match-type/src-ipv4-address/src-ipv4-prefix");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/match/route-type/ipv4/ipv4/ip-route-match-type/dest-src-ipv4-address/dest-src-ipv4-address");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/match/route-type/ipv4/ipv4/ip-route-match-type/dest-src-ipv4-address/dest-src-ipv4-address/dest-ipv4-prefix");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/match/route-type/ipv4/ipv4/ip-route-match-type/dest-src-ipv4-address/dest-src-ipv4-address/src-ipv4-prefix");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/match/route-type/ipv6/ipv6");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/match/route-type/ipv6/ipv6/ip-route-match-type/dest-ipv6-address/dest-ipv6-prefix");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/match/route-type/ipv6/ipv6/ip-route-match-type/src-ipv6-address/src-ipv6-prefix");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/match/route-type/ipv6/ipv6/ip-route-match-type/dest-src-ipv6-address/dest-src-ipv6-address");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/match/route-type/ipv6/ipv6/ip-route-match-type/dest-src-ipv6-address/dest-src-ipv6-address/dest-ipv6-prefix");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/match/route-type/ipv6/ipv6/ip-route-match-type/dest-src-ipv6-address/dest-src-ipv6-address/src-ipv6-prefix");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/match/route-type/mpls-route/mpls-label");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/match/route-type/mac-route/mac-address");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/match/route-type/interface-route/interface-identifier");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-id");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/sharing-flag");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/special-nexthop/special");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/egress-interface-nexthop/outgoing-interface");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/ipv4-address-nexthop/ipv4-address");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/ipv6-address-nexthop/ipv6-address");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/egress-interface-ipv4-nexthop/egress-interface-ipv4-address");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/egress-interface-ipv4-nexthop/egress-interface-ipv4-address/outgoing-interface");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/egress-interface-ipv4-nexthop/egress-interface-ipv4-address/ipv4-address");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/egress-interface-ipv6-nexthop/egress-interface-ipv6-address");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/egress-interface-ipv6-nexthop/egress-interface-ipv6-address/outgoing-interface");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/egress-interface-ipv6-nexthop/egress-interface-ipv6-address/ipv6-address");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/egress-interface-mac-nexthop/egress-interface-mac-address");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/egress-interface-mac-nexthop/egress-interface-mac-address/outgoing-interface");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/egress-interface-mac-nexthop/egress-interface-mac-address/ieee-mac-address");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/ipv4/ipv4-header");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/ipv4/ipv4-header/src-ipv4-address");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/ipv4/ipv4-header/dest-ipv4-address");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/ipv4/ipv4-header/protocol");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/ipv4/ipv4-header/ttl");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/ipv4/ipv4-header/dscp");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/ipv6/ipv6-header");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/ipv6/ipv6-header/src-ipv6-address");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/ipv6/ipv6-header/dest-ipv6-address");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/ipv6/ipv6-header/next-header");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/ipv6/ipv6-header/traffic-class");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/ipv6/ipv6-header/flow-label");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/ipv6/ipv6-header/hop-limit");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/mpls/mpls-header");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/mpls/mpls-header/label-operations");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/mpls/mpls-header/label-operations/label-oper-id");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/mpls/mpls-header/label-operations/label-actions/label-push/label-push");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/mpls/mpls-header/label-operations/label-actions/label-push/label-push/label");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/mpls/mpls-header/label-operations/label-actions/label-push/label-push/s-bit");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/mpls/mpls-header/label-operations/label-actions/label-push/label-push/tc-value");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/mpls/mpls-header/label-operations/label-actions/label-push/label-push/ttl-value");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/mpls/mpls-header/label-operations/label-actions/label-swap/label-swap");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/mpls/mpls-header/label-operations/label-actions/label-swap/label-swap/in-label");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/mpls/mpls-header/label-operations/label-actions/label-swap/label-swap/out-label");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/mpls/mpls-header/label-operations/label-actions/label-swap/label-swap/ttl-action");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/gre/gre-header");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/gre/gre-header/dest-address-type/ipv4/ipv4-dest");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/gre/gre-header/dest-address-type/ipv6/ipv6-dest");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/gre/gre-header/protocol-type");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/gre/gre-header/key");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/nvgre/nvgre-header");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/nvgre/nvgre-header/nvgre-type/ipv4/src-ipv4-address");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/nvgre/nvgre-header/nvgre-type/ipv4/dest-ipv4-address");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/nvgre/nvgre-header/nvgre-type/ipv4/protocol");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/nvgre/nvgre-header/nvgre-type/ipv4/ttl");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/nvgre/nvgre-header/nvgre-type/ipv4/dscp");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/nvgre/nvgre-header/nvgre-type/ipv6/src-ipv6-address");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/nvgre/nvgre-header/nvgre-type/ipv6/dest-ipv6-address");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/nvgre/nvgre-header/nvgre-type/ipv6/next-header");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/nvgre/nvgre-header/nvgre-type/ipv6/traffic-class");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/nvgre/nvgre-header/nvgre-type/ipv6/flow-label");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/nvgre/nvgre-header/nvgre-type/ipv6/hop-limit");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/nvgre/nvgre-header/virtual-subnet-id");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/nvgre/nvgre-header/flow-id");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/vxlan/vxlan-header");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/vxlan/vxlan-header/vxlan-type/ipv4/src-ipv4-address");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/vxlan/vxlan-header/vxlan-type/ipv4/dest-ipv4-address");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/vxlan/vxlan-header/vxlan-type/ipv4/protocol");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/vxlan/vxlan-header/vxlan-type/ipv4/ttl");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/vxlan/vxlan-header/vxlan-type/ipv4/dscp");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/vxlan/vxlan-header/vxlan-type/ipv6/src-ipv6-address");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/vxlan/vxlan-header/vxlan-type/ipv6/dest-ipv6-address");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/vxlan/vxlan-header/vxlan-type/ipv6/next-header");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/vxlan/vxlan-header/vxlan-type/ipv6/traffic-class");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/vxlan/vxlan-header/vxlan-type/ipv6/flow-label");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/vxlan/vxlan-header/vxlan-type/ipv6/hop-limit");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-encap-nexthop/tunnel-encap/tunnel-type/vxlan/vxlan-header/vxlan-identifier");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-decap-nexthop/tunnel-decap");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-decap-nexthop/tunnel-decap/tunnel-type/ipv4/ipv4-decap");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-decap-nexthop/tunnel-decap/tunnel-type/ipv4/ipv4-decap/ipv4-decap");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-decap-nexthop/tunnel-decap/tunnel-type/ipv4/ipv4-decap/ttl-action");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-decap-nexthop/tunnel-decap/tunnel-type/ipv6/ipv6-decap");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-decap-nexthop/tunnel-decap/tunnel-type/ipv6/ipv6-decap/ipv6-decap");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-decap-nexthop/tunnel-decap/tunnel-type/ipv6/ipv6-decap/hop-limit-action");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-decap-nexthop/tunnel-decap/tunnel-type/mpls/label-pop");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-decap-nexthop/tunnel-decap/tunnel-type/mpls/label-pop/label-pop");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/tunnel-decap-nexthop/tunnel-decap/tunnel-type/mpls/label-pop/ttl-action");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/logical-tunnel-nexthop/logical-tunnel");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/logical-tunnel-nexthop/logical-tunnel/tunnel-type");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/logical-tunnel-nexthop/logical-tunnel/tunnel-name");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/rib-name-nexthop/rib-name");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-base/nexthop-base/nexthop-base-type/nexthop-identifier/nexthop-ref");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-chain/nexthop-chain");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-chain/nexthop-chain/nexthop-list");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-chain/nexthop-chain/nexthop-list/nexthop-member-id");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-replicates/nexthop-replicates");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-replicates/nexthop-replicates/nexthop-list");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-replicates/nexthop-replicates/nexthop-list/nexthop-member-id");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-protection/nexthop-protection");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-protection/nexthop-protection/nexthop-list");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-protection/nexthop-protection/nexthop-list/nexthop-member-id");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-protection/nexthop-protection/nexthop-list/nexthop-preference");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-load-balance/nexthop-lb");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-load-balance/nexthop-lb/nexthop-list");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-load-balance/nexthop-lb/nexthop-list/nexthop-member-id");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/nexthop/nexthop-type/nexthop-load-balance/nexthop-lb/nexthop-list/nexthop-lb-weight");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/route-status");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/route-attributes");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/route-attributes/route-preference");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/route-attributes/local-only");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/route-attributes/address-family-route-attributes");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/route-list/route-vendor-attributes");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/nexthop-list");

  agt_cb_unregister_callbacks(
    y_ietf_i2rs_rib_M_ietf_i2rs_rib,
    (const xmlChar *)"/routing-instance/rib-list/nexthop-list/nexthop-member-id");

  /* put your cleanup code here */
  
} /* y_ietf_i2rs_rib_cleanup */

/* END ietf_i2rs_rib.c */

